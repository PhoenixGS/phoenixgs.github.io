<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PhoenixGS</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://x.phoenixgs.cn/"/>
  <updated>2020-08-06T14:40:04.382Z</updated>
  <id>http://x.phoenixgs.cn/</id>
  
  <author>
    <name>PhoenixGS</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>min-max容斥</title>
    <link href="http://x.phoenixgs.cn/min-max%E5%AE%B9%E6%96%A5/"/>
    <id>http://x.phoenixgs.cn/min-max容斥/</id>
    <published>2020-08-06T14:15:24.000Z</published>
    <updated>2020-08-06T14:40:04.382Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="min-max容斥"><a href="#min-max容斥" class="headerlink" title="min-max容斥"></a>min-max容斥</h1><h2 id="min-max容斥-1"><a href="#min-max容斥-1" class="headerlink" title="min-max容斥"></a>min-max容斥</h2><p>$$<br>max(S)=\sum_{T\subseteq S}(-1)^{|T|-1}min(T)<br>$$</p><p>$$<br>min(S)=\sum_{T\subseteq S}(-1)^{|T|-1}max(T)<br>$$</p><a id="more"></a><h2 id="广义min-max容斥"><a href="#广义min-max容斥" class="headerlink" title="广义min-max容斥"></a>广义min-max容斥</h2><p>$$<br>max(S, k)=\sum_{T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}min(T)<br>$$</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>对于第$t$大的数，它的贡献为：<br>$$<br>\sum_{i=0}^t\binom{t-1}{i-1}(-1)^{i-t}\binom{i-1}{k-1}=\binom{t-1}{k-1}\sum_{i=0}^t\binom{t-k}{i-k}(-1)^{t-i}=[t==k]<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;min-max容斥&quot;&gt;&lt;a href=&quot;#min-max容斥&quot; class=&quot;headerlink&quot; title=&quot;min-max容斥&quot;&gt;&lt;/a&gt;min-max容斥&lt;/h1&gt;&lt;h2 id=&quot;min-max容斥-1&quot;&gt;&lt;a href=&quot;#min-max容斥-1&quot; class=&quot;headerlink&quot; title=&quot;min-max容斥&quot;&gt;&lt;/a&gt;min-max容斥&lt;/h2&gt;&lt;p&gt;$$&lt;br&gt;max(S)=\sum_{T\subseteq S}(-1)^{|T|-1}min(T)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;min(S)=\sum_{T\subseteq S}(-1)^{|T|-1}max(T)&lt;br&gt;$$&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学" scheme="http://x.phoenixgs.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="组合数学" scheme="http://x.phoenixgs.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>虚树</title>
    <link href="http://x.phoenixgs.cn/%E8%99%9A%E6%A0%91/"/>
    <id>http://x.phoenixgs.cn/虚树/</id>
    <published>2020-07-26T07:53:50.000Z</published>
    <updated>2020-07-26T08:00:15.566Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h1><blockquote><p> 之前在主站写过一篇虚树的博客，但是主站因为忘记续费然后直接没了。。。</p></blockquote><p>有一个非常显然的结论，对于$dfs$序连续的三个点$x,y,z$，有$lca(x,z)\in {lca(x,y),lca(y,z)}$，这个用分类讨论什么的很容易证明</p><a id="more"></a><p>那么建虚树就只要将所有关键点按照$dfs$排序之后，将相邻的点的$lca$加入即可</p><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">bool comp(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">return dfn[x] &lt; dfn[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">while (m--)</span><br><span class="line">&#123;</span><br><span class="line">int cnt = read();</span><br><span class="line">for (int i = 1; i &lt;= cnt; i++)</span><br><span class="line">&#123;</span><br><span class="line">x[i] = read();</span><br><span class="line">flag[x[i]] = 1;</span><br><span class="line">&#125;</span><br><span class="line">cnt++;</span><br><span class="line">x[cnt] = 1;</span><br><span class="line">std::sort(x + 1, x + cnt + 1, comp);</span><br><span class="line">cnt = std::unique(x + 1, x + cnt + 1) - x - 1;</span><br><span class="line">for (int i = 1, tmp = cnt; i &lt; tmp; i++)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">x[cnt] = querylca(x[i], x[i + 1]);</span><br><span class="line">&#125;</span><br><span class="line">std::sort(x + 1, x + cnt + 1, comp);</span><br><span class="line">cnt = std::unique(x + 1, x + cnt + 1) - x - 1;</span><br><span class="line">top = 1;</span><br><span class="line">stack[top] = x[1];</span><br><span class="line">for (int i = 2; i &lt;= cnt; i++)</span><br><span class="line">&#123;</span><br><span class="line">while (top &gt; 0 &amp;&amp; deep[stack[top]] &gt; deep[querylca(stack[top], x[i])])</span><br><span class="line">&#123;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">if (stack[top])</span><br><span class="line">&#123;</span><br><span class="line">add(stack[top], x[i], 0);</span><br><span class="line">&#125;</span><br><span class="line">top++;</span><br><span class="line">stack[top] = x[i];</span><br><span class="line">&#125;</span><br><span class="line">solve(1, 0);</span><br><span class="line">printf(&quot;%lld\n&quot;, f[1]);</span><br><span class="line"></span><br><span class="line">edgenum = 0;</span><br><span class="line">for (int i = 1; i &lt;= cnt; i++)</span><br><span class="line">&#123;</span><br><span class="line">flag[x[i]] = 0;</span><br><span class="line">head[x[i]] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;虚树&quot;&gt;&lt;a href=&quot;#虚树&quot; class=&quot;headerlink&quot; title=&quot;虚树&quot;&gt;&lt;/a&gt;虚树&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 之前在主站写过一篇虚树的博客，但是主站因为忘记续费然后直接没了。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有一个非常显然的结论，对于$dfs$序连续的三个点$x,y,z$，有$lca(x,z)\in {lca(x,y),lca(y,z)}$，这个用分类讨论什么的很容易证明&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
