<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PhoenixGS</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://x.phoenixgs.cn/"/>
  <updated>2018-12-27T13:09:47.743Z</updated>
  <id>http://x.phoenixgs.cn/</id>
  
  <author>
    <name>PhoenixGS</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多项式求逆</title>
    <link href="http://x.phoenixgs.cn/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86/"/>
    <id>http://x.phoenixgs.cn/多项式求逆/</id>
    <published>2018-12-27T13:07:54.000Z</published>
    <updated>2018-12-27T13:09:47.743Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="定义">定义</h1><p>我们说<span class="math inline">\(B(x)\)</span>是<span class="math inline">\(A(x)\)</span>在模<span class="math inline">\(x^n\)</span>意义下的逆元则是满足</p><p><span class="math display">\[A(x)*B(x)\equiv1(mod \; x^n)\]</span></p><h1 id="分治">分治</h1><p>考虑分治</p><p>假如我们已经知道在模<span class="math inline">\(x^{\lceil \frac{n}{2} \rceil}\)</span>下<span class="math inline">\(A\)</span>的逆<span class="math inline">\(B&#39;\)</span></p><a id="more"></a><p>即</p><p><span class="math display">\[A(x)*B&#39;(x)\equiv 1(mod \; x^{\lceil \frac{n}{2} \rceil})\]</span></p><p><span class="math display">\[A(x)*B&#39;(x)-1\equiv 0(mod \; x^{\lceil \frac{n}{2} \rceil})\]</span></p><p>两边平方即可得</p><p><span class="math display">\[(A(x)*B&#39;(x)-1)^2\equiv 0(mod \; x^{2\lceil \frac{n}{2} \rceil})\]</span></p><p>显然<span class="math inline">\(2\lceil \frac{n}{2} \rceil \geq n\)</span></p><p>所以</p><p><span class="math display">\[(A(x)*B&#39;(x)-1)^2\equiv 0(mod \; x^n)\]</span></p><p><span class="math display">\[A^2(x)*B&#39;^2(x)-2A(x)*B&#39;(x)+1\equiv 0(mod \; x^n)\]</span></p><p><span class="math display">\[2A(x)*B&#39;(x)-A^2(x)*B&#39;^2(x)\equiv 1(mod \; x^n)\]</span></p><p><span class="math display">\[A(x)(2B&#39;(x)-A(x)*B&#39;^2(x))\equiv 1(mod \; x^n)\]</span></p><p>那么<span class="math inline">\(B(x)=2B&#39;(x)-A(x)*B&#39;^2(x)\)</span>即为满足<span class="math inline">\(A(x)*B(x)\equiv 1(mod \; x^n)\)</span>的<span class="math inline">\(B(x)\)</span></p><h1 id="参考资料">参考资料</h1><ol type="1"><li><p><a href="http://nirobc.com/20181212.pdf" class="uri" target="_blank" rel="noopener">http://nirobc.com/20181212.pdf</a></p></li><li><p><a href="https://www.cnblogs.com/yoyoball/p/8724115.html" class="uri" target="_blank" rel="noopener">https://www.cnblogs.com/yoyoball/p/8724115.html</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;定义&lt;/h1&gt;
&lt;p&gt;我们说&lt;span class=&quot;math inline&quot;&gt;\(B(x)\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;在模&lt;span class=&quot;math inline&quot;&gt;\(x^n\)&lt;/span&gt;意义下的逆元则是满足&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[A(x)*B(x)\equiv1(mod \; x^n)\]&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&quot;分治&quot;&gt;分治&lt;/h1&gt;
&lt;p&gt;考虑分治&lt;/p&gt;
&lt;p&gt;假如我们已经知道在模&lt;span class=&quot;math inline&quot;&gt;\(x^{\lceil \frac{n}{2} \rceil}\)&lt;/span&gt;下&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;的逆&lt;span class=&quot;math inline&quot;&gt;\(B&amp;#39;\)&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://x.phoenixgs.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://x.phoenixgs.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="FFT与NTT" scheme="http://x.phoenixgs.cn/tags/FFT%E4%B8%8ENTT/"/>
    
  </entry>
  
  <entry>
    <title>FFT与NTT</title>
    <link href="http://x.phoenixgs.cn/FFT%E4%B8%8ENTT/"/>
    <id>http://x.phoenixgs.cn/FFT与NTT/</id>
    <published>2018-12-27T13:05:58.000Z</published>
    <updated>2018-12-27T13:09:51.483Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="快速傅立叶变换-fft">快速傅立叶变换 FFT</h1><p>对于两个多项式</p><p><span class="math display">\[A(x)=\sum_{i=0}^{N-1}a_ix^i\]</span></p><p><span class="math display">\[B(x)=\sum_{i=0}^{N-1}b_ix^i\]</span></p><p>FFT可以在<span class="math inline">\(O(nlgn)\)</span>的时间内求出</p><p><span class="math display">\[C(x)=A(x)*B(x)=\sum_{i=0}^{2(N-1)}c_ix^i\]</span></p><p>其中<span class="math inline">\(c_i=\sum_{j=0}^ia_jb_{i-j}\)</span></p><a id="more"></a><h2 id="前置知识">前置知识</h2><p>在复数域下，方程<span class="math inline">\(x^n=1\)</span>有<span class="math inline">\(n\)</span>个解<span class="math inline">\(\omega_N^i,(i=1\dots N)\)</span></p><p>其中</p><p><span class="math display">\[\omega_N^i=(\cos\frac{2\pi i}{N}, \sin\frac{2\pi i}{N})\]</span></p><p>可以看作是平面直角坐标系中单位圆上间距相等的<span class="math inline">\(N\)</span>个点</p><p>然后可以自己去<a href="https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6)" target="_blank" rel="noopener">学习一下复数</a>一下qwq</p><p>假如把复数用极坐标表示</p><p><span class="math inline">\(z=r(\cos \varphi+i\sin \varphi)\)</span></p><p>那么复数的乘法就是模长(<span class="math inline">\(r\)</span>)相乘，幅角(<span class="math inline">\(\varphi\)</span>)相加</p><p>单位根有如下性质：</p><p><span class="math display">\[\omega_N^i\omega_N^j=\omega_N^{i+j}\]</span></p><p><span class="math display">\[\omega_N^i=\omega_N^{N+i}\]</span></p><p><span class="math display">\[\omega_N^{\frac{N}{2}}=-1\]</span></p><p><span class="math display">\[\omega_N^i=\omega_{cN}^{ci}\]</span></p><h2 id="dft">DFT</h2><p>我们尝试将<span class="math inline">\(N\)</span>下的单位根代入多项式得到<span class="math inline">\(N\)</span>个值</p><p>也就是</p><p><span class="math display">\[F:\{a_0,a_1,\dots a_{N-1}\} \to \{A(\omega_0),A(\omega_1),\dots A(\omega_{N-1})\}\]</span></p><p>显然，可以在<span class="math inline">\(A,B\)</span>中补<span class="math inline">\(0\)</span>使得<span class="math inline">\(N=2^k(k\in \mathbb{N})\)</span></p><p>考虑分治</p><p>对于<span class="math inline">\(0\leq i &lt; \frac{N}{2}\)</span></p><p>有</p><p><span class="math display">\[\begin{aligned}A_i&amp;=\sum_{j=0}^{N-1}a_j\omega_N^{ij}\\A_{i+\frac{N}{2}}&amp;=\sum_{j=0}^{N-1}a_j\omega_N^{(i+\frac{N}{2})j}=\sum_{j=0}^{N-1}(-1)^ja_j\omega_N^{ij}\end{aligned}\]</span></p><p>将<span class="math inline">\(\sum\)</span>中的奇偶项分开来</p><p><span class="math display">\[\begin{aligned}A_i&amp;=\sum_{j=0}^{\frac{N}{2}-1}a_{2j}\omega_{\frac{N}{2}}^{ij}+\omega_N^i\sum_{j=0}^{\frac{N}{2}-1}a_{2j+1}\omega_{\frac{N}{2}}^{ij}\\A_{i+\frac{N}{2}}&amp;=\sum_{j=0}^{\frac{N}{2}-1}a_{2j}\omega_{\frac{N}{2}}^{ij}-\omega_N^i\sum_{j=0}^{\frac{N}{2}-1}a_{2j+1}\omega_{\frac{N}{2}}^{ij}\end{aligned}\]</span></p><p>非常奇妙是不是？这样就可以分治下去啦</p><h2 id="idft">IDFT</h2><p>与DFT类似</p><p>只不过将DFT中的每个<span class="math inline">\(\omega\)</span>都变成<span class="math inline">\(\omega^{-1}\)</span>，然后最后每个<span class="math inline">\(A_i\)</span>都除以<span class="math inline">\(N\)</span></p><p>代入进去显然可以发现是对的。</p><p>如果要严格说明是唯一的话就要用线性代数中的Vandermonde矩阵了。。</p><p>这里就不写了，感兴趣的可以去了解一下，《算法导论》里讲的也挺详细的</p><h2 id="例题">例题</h2><p>来自衲姐NiroBC的例题（Orz）</p><blockquote><p>给一个<span class="math inline">\(N\)</span>位的<span class="math inline">\(B\)</span>进制数<span class="math inline">\(A\)</span>，将它转为十进制。(<span class="math inline">\(N,B\leq 10^5\)</span>)</p></blockquote><p>考虑分治</p><p>对于<span class="math inline">\(N\)</span>位的<span class="math inline">\(B\)</span>进制数，</p><p>设<span class="math inline">\(M=2^k\leq \frac{N}{2}\)</span></p><p>假如我们已经求出了<span class="math inline">\(\sum_{i=0}^{M-1}A_iB^i\)</span>的十进制数以及<span class="math inline">\(\sum_{i=0}^{N-M-1}A_{i+M}B^i\)</span>的十进制数</p><p>那么就可以用FFT将<span class="math inline">\(\sum_{i=0}^{N-M-1}A_{i+M}B^i\)</span>乘上<span class="math inline">\(B^M\)</span></p><p>其中<span class="math inline">\(B^M\)</span>的十进制数也可以用FFT预处理</p><p>时间复杂度为<span class="math inline">\(O(nlg^2n)\)</span></p><h1 id="快速数论变换-ntt">快速数论变换 NTT</h1><p>NTT与FFT大体上十分相似</p><p>主要是因为FFT涉及许多实数运算，因此很容易丢精</p><p>当需要对所求的多项式对<span class="math inline">\(M\)</span>取模时，NTT就是一个非常好的选择</p><blockquote><p><a href="https://zh.wikipedia.org/zh-hk/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA)" target="_blank" rel="noopener">欧拉定理</a>： 若<span class="math inline">\(n,a\)</span>为正整数，且<span class="math inline">\(n,a\)</span>互素（即<span class="math inline">\(\gcd(a,n)=1\)</span>），则 <span class="math display">\[a^{\varphi(n)}\equiv 1 \quad (mod\; n)\]</span></p></blockquote><p>NTT一般用于<span class="math inline">\(M\)</span>是质数的情况，因此在这里费马小定理：</p><blockquote><p><a href="https://zh.wikipedia.org/zh-hk/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">费马小定理</a>： 假如<span class="math inline">\(a\)</span>是一个整数，<span class="math inline">\(p\)</span>是一个质数 <span class="math display">\[a^{p-1}\equiv 1 \quad (mod\; p)\]</span></p></blockquote><p><a href="https://zh.wikipedia.org/wiki/原根" target="_blank" rel="noopener">原根</a><span class="math inline">\(G\)</span>，满足集合<span class="math inline">\(\{G^0, G^1, G^2, \cdots, G^{\varphi(M) - 1}\}\)</span>中含有了所有与<span class="math inline">\(M\)</span>互质的数。</p><p>若<span class="math inline">\(M\)</span>可以表示成<span class="math inline">\(2^k*t+1\)</span>， 其中<span class="math inline">\(t\)</span>是奇数</p><p>那么对于小于<span class="math inline">\(2^k\)</span>的<span class="math inline">\(N\)</span>，<span class="math inline">\(G^{\frac{M-1}{N}}\)</span>都可以作为单位元<span class="math inline">\(w\)</span>，其他就和FFT没什么区别了</p><h1 id="参考资料">参考资料</h1><ol type="1"><li><p><a href="http://nirobc.com/20181205.pdf" class="uri" target="_blank" rel="noopener">http://nirobc.com/20181205.pdf</a></p></li><li><p><a href="http://nirobc.com/20181212.pdf" class="uri" target="_blank" rel="noopener">http://nirobc.com/20181212.pdf</a></p></li><li><p><a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform" class="uri" target="_blank" rel="noopener">http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;快速傅立叶变换-fft&quot;&gt;快速傅立叶变换 FFT&lt;/h1&gt;
&lt;p&gt;对于两个多项式&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[A(x)=\sum_{i=0}^{N-1}a_ix^i\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[B(x)=\sum_{i=0}^{N-1}b_ix^i\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;FFT可以在&lt;span class=&quot;math inline&quot;&gt;\(O(nlgn)\)&lt;/span&gt;的时间内求出&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[C(x)=A(x)*B(x)=\sum_{i=0}^{2(N-1)}c_ix^i\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(c_i=\sum_{j=0}^ia_jb_{i-j}\)&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://x.phoenixgs.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://x.phoenixgs.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="FFT与NTT" scheme="http://x.phoenixgs.cn/tags/FFT%E4%B8%8ENTT/"/>
    
  </entry>
  
</feed>
