{"meta":{"title":"PhoenixGS","subtitle":null,"description":null,"author":"PhoenixGS","url":"http://x.phoenixgs.cn"},"pages":[{"title":"Categories","date":"2018-04-10T07:36:06.983Z","updated":"2018-04-10T07:36:06.949Z","comments":true,"path":"categories/index.html","permalink":"http://x.phoenixgs.cn/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-04-10T07:35:55.597Z","updated":"2018-04-10T07:35:55.561Z","comments":true,"path":"about/index.html","permalink":"http://x.phoenixgs.cn/about/index.html","excerpt":"","text":""},{"title":"TodoList","date":"2018-11-30T07:01:46.364Z","updated":"2018-11-30T07:01:46.364Z","comments":true,"path":"todolist/index.html","permalink":"http://x.phoenixgs.cn/todolist/index.html","excerpt":"","text":"Things:Done Things:Doing Things:Skip Content State Killed Date 容斥及反演 Doing 二进制分组 动态规划优化 最小表示 后缀自动机 回文自动机 FFT &amp; NTT Minmax 反演 弦图 DP 斯特林数 Min_25筛 Done 2018.11.30"},{"title":"Tags","date":"2018-04-10T07:36:14.332Z","updated":"2018-04-10T07:36:14.299Z","comments":true,"path":"tags/index.html","permalink":"http://x.phoenixgs.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Min_25筛","slug":"Min-25","date":"2018-11-30T06:47:35.000Z","updated":"2018-11-30T08:03:14.741Z","comments":true,"path":"Min-25/","link":"","permalink":"http://x.phoenixgs.cn/Min-25/","excerpt":"简介Min_25筛用来求一个函数的前缀和 如果函数是积性函数就可以做，如果不是积性函数的话有一部分也是可以做的 算法过程就像是在模拟埃氏筛法 时间复杂度是$O(\\frac{n^{\\frac{3}{4}}}{log(\\sqrt{n})})$，然而我并不会证","text":"简介Min_25筛用来求一个函数的前缀和 如果函数是积性函数就可以做，如果不是积性函数的话有一部分也是可以做的 算法过程就像是在模拟埃氏筛法 时间复杂度是$O(\\frac{n^{\\frac{3}{4}}}{log(\\sqrt{n})})$，然而我并不会证 算法\b质数的函数值的前缀和设$m(x)$表示$x$的最小质因子 假如要求 $$\\sum_{i = 1}^{n}f(i)[i是质数]$$ 首先将$\\sqrt{n}$之内的质数全部筛出来，放在prime数组里 设 $$g(n,j)=\\sum_{i = 2}^{n}f(i)[m(i) &gt; prime_j 或 i 是质数]$$ 那么 $$g(n,j) = \\begin{cases} g(n,j - 1) - f(j)[g(\\lfloor \\frac{n}{prime_j} \\rfloor, j - 1) - g(prime_{j - 1}, j - 1)] &amp; prime_j^2 \\leq n \\ g(n,j - 1) &amp; prime_j^2 &gt; n\\end{cases}$$ 显然，其中的$g(prime_{j-1},j-1)=\\sum_{i=1}^{j-1}f(prime_i)$ 那么原式中第一维有用的值只有$O(\\sqrt{n})$种，预处理即可 \b最终$g(n,primenum)$就是我们要求的$\\sum_{i = 1}^{n}f(i)[i是质数]$ 关于$f(x)$\b如果只求质数的函数值的话， $f(x)$应该满足下面几个条件： 若$x$是质数$f(x)$应该要能在$O(1)$内求出来 要能够快速求出$\\sum_{i=2}^{n}f’(i)$，其中$f’(i)=\\Pi_{j,k}f(j)[k &gt; 0][j^k|n]$ 函数值的前缀和\b递归版假设我们要求的函数是$f(x)$，那么问题就是求 $$\\sum_{i = 1}^{n}f(i)$$ 之前已经求出了 $$\\sum_{i = 1}^{n}f(i)[i是质数]$$ 的值 那么，现在设 $$h(n,j) = \\sum_{i=2}^nf(i)[m(i) \\geq prime_j]$$ 那么 $$h(n,j)=g(n,primenum) - g(prime_{i-1},i-1)+\\sum_{i=j}^{primenum}\\sum_{e\\geq 1 且 prime_i^{e+1}\\leq n}f(prime_i^e)h(\\lfloor \\frac{n}{prime_i^e} \\rfloor,i+1)+f(prime_i^{e+1})$$ 和上面一样，第一维有用的取值只有$O(\\sqrt{n})$种 写一个递归函数，\b最后的答案即为$h(n,1)+f(1)$ 假如就询问没几个$n$的答案，就可以用这种方法 \b非递归版\b这次改变一下状态 设 $$h(n,j)=\\sum_{i=2}^nf(i)[m(i)\\geq prime_j 或 i是质数]$$ \b那么 $$h(n,j)=\\begin{cases} h(n,j+1)+\\sum_{e \\geq 1 且prime_j^{e+1}\\leq n}f(prime_j^e)[h(\\lfloor \\frac{n}{prime_j^e} \\rfloor,j + 1) - g(prime_i,i)] &amp; prime_j^2 \\leq n \\ h(n,j+1) &amp; prime_j^2 &gt; n\\end{cases}$$ 有没有发现这个式子与质数函数值的前缀和的式子特别像？只不过\b质数一个是从小枚举到大，一个是从大枚举到小 \b答案为$h(n,1)+f(1)$ 假如要询问许多$n’= \\lfloor \\frac{n}{x} \\rfloor$的答案，就可以用这种方法 关于$f(x)$$f(x)$函数如果是积性函数，那么应该都可以做 假如不是的话，首先要满足求质数的函数值的前缀和的那些条件 并且若$x=ab,gcd(a,b)=1$，$f(x)$能$O(1)$从$f(a)$和$f(b)$合并，那么应该就能做了（其实我也不是很清楚qaq 关于时间复杂度暂时还不会。。。 参考资料 http://www.cnblogs.com/zzqsblog/p/8302815.html http://www.hekai.site/wordpress/2018/09/04/min_25%E7%AD%9B/ https://blog.csdn.net/XianHaoMing/article/details/80397777 https://www.cnblogs.com/Menhera/p/9226649.html https://blog.csdn.net/ZLTJohn/article/details/79703503","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://x.phoenixgs.cn/tags/算法/"},{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"},{"name":"数论","slug":"数论","permalink":"http://x.phoenixgs.cn/tags/数论/"}]},{"title":"概率论","slug":"概率论","date":"2018-10-27T14:38:38.000Z","updated":"2018-11-30T07:59:24.822Z","comments":true,"path":"概率论/","link":"","permalink":"http://x.phoenixgs.cn/概率论/","excerpt":"概念 样本空间：一个随机试验的所有可能结果组成的集合，标记为$S$ 事件：$S$的一个子集$A$，$A\\subseteq \\Omega$，称为事件","text":"概念 样本空间：一个随机试验的所有可能结果组成的集合，标记为$S$ 事件：$S$的一个子集$A$，$A\\subseteq \\Omega$，称为事件 概率公理 $0\\leq P(A)\\leq 1$ $P(\\Omega)=1$ 如果$A_1A_2A_3\\cdots$是一系列两两无关的事件，即对于任何$i,j,i\\neq j,A_i\\cap A_j=\\phi$，则 $$P\\lgroup \\bigcup_{k=1}^{\\infty} A_k \\rgroup=\\sum_{k=1}^{\\infty}P(A_k)$$ 条件概率令$B$为一个事件满足$P(B)&gt;0$，对于任意事件$A$，定义$A$的关于$B$的条件概率。$$P(A|B)=\\frac{P(A\\cap B)}{P(B)}$$ 独立如果$A,B$满足$P(A\\cap B)=P(A)P(B)$，称$A,B$独立。并且可以推出$P(A)=P(A|B)$ 性质 概率的加法公式 $$P(A\\cup B)=P(A)+P(B)-P(A\\cap B)$$ 并的界 $$P(A\\cup B)\\leq P(A)+P(B)$$ 全概率公式 设$B_1B_2B_3\\cdots B_n$是样本空间$S$中互不相交的一系列事件，并且满足$S=\\bigcup_{k=1}^n B_k$，那么对于任意事件$A$ $$P(A)=\\sum_{k=1}^nP(A|B_k)P(B_k)$$ 平均值均值$$\\sum_{x\\in X(\\Omega)}x\\cdot Pr(X=x)$$ 也就是期望值 中位数满足 $$Pr(X\\leq x) \\geq \\frac{1}{2}且Pr(X\\geq x) \\geq \\frac{1}{2}$$ 的所有$x\\in X(\\Omega)$组成的集合 众数满足 $$Pr(X = x) \\geq Pr(X=x^{‘}), \\forall x^{‘}\\in X(\\Omega)$$ 的所有$x\\in X(\\Omega)$组成的集合 期望$$EX=\\sum_{\\omega \\in \\Omega}X(\\omega)Pr(\\omega)$$ 性质$$E(X+Y)=\\sum_{\\omega \\in \\Omega}(X(\\omega)+Y(\\omega))Pr(\\omega)=EX+EY$$ $$E(\\alpha X)=\\alpha EX$$ $$E(XY)=(EX)(EY),如果X和Y是独立的$$ 方差$$VX=E((X-EX)^2)$$ 标准差$$\\sigma=\\sqrt{VX}$$ 性质因为$(EX)$是常数， $$\\begin{array}{l}VX\\\\=E((X-EX)^2)\\\\=E(X^2-2X(EX)+(EX)^2)\\\\=E(X^2)-2(EX)(EX)+(EX)^2\\\\=E(X^2)-(EX)^2\\end{array}$$ 当$X$和$Y$为独立的随机变量时， $$\\begin{array}{l}V(X+Y)\\\\=E((X+Y)^2)-(EX+EY)^2\\\\=E(X^2)+2(EX)(EY)+E(Y^2)-(EX)^2-2(EX)(EY)-(EY)^2\\\\=E(X^2)-(EX)^2+E(Y^2)-(EY)^2\\\\=VX+VY\\end{array}$$ 整数概率公式$$E(x)=\\sum_{i=1}^{\\infty}P(x\\geq i)$$ 正整数随机变量的期望等于其分别大于等于所有数的概率之和 证明$$E(x)=\\sum_{i=1}^{\\infty}iP(x=i)=\\sum_{i=1}^{\\infty}i[P(x\\geq i)-P(x\\geq i+1)]=\\sum_{i=1}^{\\infty}P(x\\geq i)$$","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"},{"name":"概率","slug":"概率","permalink":"http://x.phoenixgs.cn/tags/概率/"}]},{"title":"线性基","slug":"线性基","date":"2018-10-24T15:12:30.000Z","updated":"2018-11-30T07:59:49.282Z","comments":true,"path":"线性基/","link":"","permalink":"http://x.phoenixgs.cn/线性基/","excerpt":"简介设数集$T$，$T$的线性基为最小的一个集合$S$，$S$与$T$通过异或运算能产生的集合相同，也就是$S$是$T$的线性无关极大子集 性质 线性基的异或集合中每个元素的异或方案唯一 线性基二进制最高位互不相同","text":"简介设数集$T$，$T$的线性基为最小的一个集合$S$，$S$与$T$通过异或运算能产生的集合相同，也就是$S$是$T$的线性无关极大子集 性质 线性基的异或集合中每个元素的异或方案唯一 线性基二进制最高位互不相同 维护插入123456789101112131415161718void insert(long long x)&#123; for (int i = 60; i &gt;= 0; i--) &#123; if ((1ll &lt;&lt; i) &amp; x) &#123; if (v[i]) &#123; x = x ^ v[i]; &#125; else &#123; v[i] = x; return; &#125; &#125; &#125;&#125; 合并将一个线性基暴力插入到另一个线性基 查询一个数能否被这个线性基表示123456789101112131415161718bool query(long long x)&#123; for (int i = 60; i &gt;= 0; i--) &#123; if ((1ll &lt;&lt; i) &amp; x) &#123; if (v[i]) &#123; x = x ^ v[i]; &#125; else &#123; return false; &#125; &#125; &#125; return true;&#125; 最大值12345678ans = 0;for (int i = 51; i &gt;= 0; i--)&#123; if ((ans ^ v[i]) &gt; ans) &#123; ans = ans ^ v[i]; &#125;&#125; 第k小值123456789101112131415161718192021222324252627282930313233343536373839void build()&#123; for (int i = 0; i &lt;= 60; i++) &#123; for (int j = i - 1; j &gt;= 0; j--) &#123; if ((1ll &lt;&lt; j) &amp; v[i]) &#123; v[i] ^= v[j]; &#125; &#125; &#125; last = 0; for (int i = 0; i &lt;= 60; i++) &#123; if (v[i]) &#123; vv[last] = v[i]; last++; &#125; &#125;&#125;long long query(long long k)&#123; if (k &gt;= (1ll &lt;&lt; last)) &#123; return (long long)-1; &#125; long long ans = 0; for (int i = 0; i &lt; last; i++) &#123; if ((1ll &lt;&lt; i) &amp; k) &#123; ans = ans ^ vv[i]; &#125; &#125; return ans;&#125; 参考https://blog.csdn.net/qaq__qaq/article/details/53812883","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"},{"name":"线性基","slug":"线性基","permalink":"http://x.phoenixgs.cn/tags/线性基/"}]},{"title":"关于证明","slug":"证明","date":"2018-10-23T15:30:35.000Z","updated":"2018-11-30T08:00:33.192Z","comments":true,"path":"证明/","link":"","permalink":"http://x.phoenixgs.cn/证明/","excerpt":"证明的方法用来证明形如$\\forall x(P(x)\\to Q(x))$的定理\u001b 直接证明法也就是条件语句$p\\to q$ 反证法\b条件语句$p\\to q$等价于它的逆否命题$\\neg q \\to \\neg p$","text":"证明的方法用来证明形如$\\forall x(P(x)\\to Q(x))$的定理\u001b 直接证明法也就是条件语句$p\\to q$ 反证法\b条件语句$p\\to q$等价于它的逆否命题$\\neg q \\to \\neg p$ 空证明和平凡证明空证明如果知道$p$为假，那么就能证明条件语句$p \\to q$为真 平凡证明如果\u001b知道$q$为真，那么就能证明条件语句$p \\to q$为真 归谬证明法假如要证明命题$p$是真的。假定我们能找到一个矛盾式$q$使得$\\neg p \\to q$为真。那么这就意味着$p$为真 因为$r \\land \\neg r$一定是一个矛盾式，所以如果我们能够证明对某个命题$r$，$\\neg p \\to (r \\land \\neg r)$为真，就能证明$p$是真的。 \b举例证明$\\sqrt{2}$是无理数 证明设$p$是命题“$\\sqrt{2}$是无理数“。假定$\\neg p$为真，即“$\\sqrt{2}$为有理数，则存在整数$a$和$b$满足$\\sqrt{2}=\\frac{a}{b}$其中$b \\neq 0$并且$a$和$b$没有公因子 等式两端取平方，则 $$2=\\frac{a^2}{b^2}$$ 因此 $$2b^2=a^2$$ 可得$a^2$是偶数，通过反证法可得出$a$也是偶数，那么$\\exists c$有$a=2c$。那么 $$2b^2=4c^2$$ 等式两端除以$2$得 $$b^2=2c^2$$ 同理可得$b$是偶数。 我们证明了假设$\\neg p$导致等式$\\sqrt{2}=\\frac{a}{b}$并且$a$和$b$没有公因子，又推出$a$和$b$有公因子$2$，推出了矛盾，因此证明了$p$为真 等价证明法为了证明一个双条件命题的定理，即形如$p \\leftrightarrow q$的语句，那么只需证明$p \\to q$和$q \\to p$都是真的。 因为 $$(p \\leftrightarrow q) \\leftrightarrow(p \\to q) \\land (q \\to p)$$ 反例证明法如果要证明形如$\\forall x P(x)$的语句为假，只要能找到一个反例$x$使$P(x)$为假 穷举证明法和分情形证明法为了证明如下的条件语句 $$(p_1 \\lor p_2 \\lor \\cdots \\lor p_n) \\to q$$\b可以用永真式 $$[(p_1 \\lor p_2 \\lor \\cdots \\lor p_n) \\to q] \\leftrightarrow [(p_1 \\to q) \\land (p_2 \\to q) \\land \\cdots \\land (p_n \\to q)]$$ 这种论证称为分情形\b证明法 穷举证明法如果一些证明只需通过检验相对少量的例子来证明，那么这样的证明叫做穷举证明法，一个穷举证明法是分情形证明的特例 分情形证明法分情形证明一定要覆盖定理中出现的所有可能情况 存在性证明$\\exists xP(x)$这类命题的证明称为存在性证明。 有时可以通过找出一个使得$P(a)$为真的元素$a$来给出$\\exists xP(x)$的存在性证明。这样的存在性证明称为是构造性的，也可以给出一种非构造性的存在性证明，即不是找出使$P(a)$为真的元素$a$，而是以某种其他方式来证明$\\exists xP(x)$为真。给出非构造性证明的一种常用方法是使用归谬证明，证明该存在量化式的否定式蕴含一个矛盾。 一个非构造性的存在性证明证明存在无理数$x$和$y$使得$x^y$是有理数 证明由之前的例子可得$\\sqrt{2}$是无理数，考虑数$\\sqrt{2}^{\\sqrt{2}}$，如果它是有理数，那就存在两个无理数$x$和$y$是有理数，即$x=\\sqrt{2}, y=\\sqrt{2}$，另一方面如果$\\sqrt{2}^{\\sqrt{2}}$是无理数，那么令$x=\\sqrt{2}^{\\sqrt{2}},y=\\sqrt{2}$\b，因此$x^y=(\\sqrt{2}^{\\sqrt{2}})^{\\sqrt{2}}=\\sqrt{2}^{(\\sqrt{2}\\cdot \\sqrt{2})}=\\sqrt{2}^{2}=2$ 唯一性证明唯一性证明的两个部分如下 存在性：证明存在某个元素$x$具有期望的性质 唯一性：证明如果$y \\neq x$，则$y$不具有期望的性质\b 我们也可以等价地证明如果$x$和$y$都具有期望的性质，则$x=y$","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"}]},{"title":"反演","slug":"反演","date":"2018-10-16T15:08:32.000Z","updated":"2018-11-30T07:58:50.153Z","comments":true,"path":"反演/","link":"","permalink":"http://x.phoenixgs.cn/反演/","excerpt":"","text":"反演原理设 $$ g_n = \\sum_{i = 0} ^ n a_{ni}f_i $$ $$ \\sum_{i = 0}^n b_{ni}g_i = f_n $$ 因此，反演公式要成立，即 $$ \\sum_{k = j}^ib_{ik}a_{kj} = [i = j] = \\delta_{ij} $$ $$ \\sum_{k = j}^ia_{ik}b_{kj} = [i = j] = \\delta_{ij} $$ 二项式反演","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"}]},{"title":"Prufer序","slug":"Prufer","date":"2018-10-16T15:05:16.000Z","updated":"2018-11-30T07:58:37.058Z","comments":true,"path":"Prufer/","link":"","permalink":"http://x.phoenixgs.cn/Prufer/","excerpt":"Prufer序一个Prufer数列和一个带编号的无根树是一一对应的 树-&gt;Prufer序每次找这棵树中编号最小的叶子节点，将与这个点相连的点加入Prufer序，去掉这个点以及相连的边。重复这个操作直到剩下两个点。 Prufer序-&gt;树设点集$ V={1,2,…,n} $，每次在$V$中找出最小的未在Prufer序中出现过的数，然后在$V$中删除，与Prufer序中的第一个数相连，Prufer序中的第一个数删除。重复这个操作直到$|V|=2$（Prufer序为空），最后将$V$中的两个点相连。","text":"Prufer序一个Prufer数列和一个带编号的无根树是一一对应的 树-&gt;Prufer序每次找这棵树中编号最小的叶子节点，将与这个点相连的点加入Prufer序，去掉这个点以及相连的边。重复这个操作直到剩下两个点。 Prufer序-&gt;树设点集$ V={1,2,…,n} $，每次在$V$中找出最小的未在Prufer序中出现过的数，然后在$V$中删除，与Prufer序中的第一个数相连，Prufer序中的第一个数删除。重复这个操作直到$|V|=2$（Prufer序为空），最后将$V$中的两个点相连。 证明这个感性理解一下感觉很有道理的 ​ 注意到，如果一个节点A不是叶子节点，那么它至少有两条边；但在上述过程结束后，整个图只剩下一条边，因此节点A的至少一个相邻节点被去掉过，节点A的编号将会在这棵树对应的Prüfer编码中出现。反过来，在Prüfer编码中出现过的数字显然不可能是这棵树（初始时）的叶子。于是我们看到，没有在Prüfer编码中出现过的数字恰好就是这棵树（初始时）的叶子节点。找出没有出现过的数字中最小的那一个（比如④），它就是与Prüfer编码中第一个数所标识的节点（比如③）相邻的叶子。接下来，我们递归地考虑后面n-3位编码（别忘了编码总长是n-2）：找出除④以外不在后n-3位编码中的最小的数（左图的例子中是⑦），将它连接到整个编码的第2个数所对应的节点上（例子中还是③）。再接下来，找出除④和⑦以外后n-4位编码中最小的不被包含的数，做同样的处理……依次把③⑧②⑤⑥与编码中第3、4、5、6、7位所表示的节点相连。最后，我们还有①和⑨没处理过，直接把它们俩连接起来就行了。由于没处理过的节点数总比剩下的编码长度大2，因此我们总能找到一个最小的没在剩余编码中出现的数，算法总能进行下去。这样，任何一个Prüfer编码都唯一地对应了一棵无根树，有多少个n-2位的Prüfer编码就有多少个带标号的无根树。 ——摘自Matrix67 性质 一棵n个节点的无根树唯一地对应了一个长度为n-2的数列，数列中的每个数都在1到n的范围内。 Prufer序列中某个编号出现的次数就等于这个编号的节点在无根树中的度数-1。 设无根树每个点的度数为$D_i$，则$\\sum_{i=1}^n(D_i-1)=n-2$（这好像是废话，，，因为$\\sum_{i=1}^nD_i=2(n-1)$。。。 Cayley公式Cayley公式一个完全图$K_n$有$n^{n-2}$棵生成树 证明由Prufer可知，一个Prufer数列和一个带编号的无根树是一一对应的，那么这个公式也很显然了。因为$n$个节点的无根树的Prufer序长度为$n-2$，序列中每个值取值为${1,2,3,…,n}$，因此不同的Prufer序有$n^{n-2}$个，因此生成树也有这么多个。 推广n个节点的度依次为$D_1,D_2,…,D_n$的无根树共有$\\frac{(n-2)!}{(D_1-1)!(D_2-1)!\\cdots(D_n-1)!}$个。 例题BZOJ1005 LOJ6395 https://www.cnblogs.com/onioncyc/p/9052946.html 参考资料http://www.matrix67.com/blog/archives/682 https://www.cnblogs.com/dirge/p/5503289.html","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://x.phoenixgs.cn/tags/算法/"},{"name":"树","slug":"树","permalink":"http://x.phoenixgs.cn/tags/树/"}]},{"title":"容斥原理","slug":"容斥原理","date":"2018-06-11T14:14:15.000Z","updated":"2018-11-30T07:58:59.235Z","comments":true,"path":"容斥原理/","link":"","permalink":"http://x.phoenixgs.cn/容斥原理/","excerpt":"表达式容斥原理$$ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1}|A_i|- \\sum_{1 \\leq i &lt; j \\leq n}|A_i \\cap A_j|+\\\\ \\sum_{1 \\leq i &lt; j &lt; k \\leq n}|A_i \\cap A_j \\cap A_k| - \\cdots +(-1)^{n-1}|A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$$$ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1} |A_i| - \\sum_{1 \\leq i &lt; j \\leq n} |A_i \\cap A_j|+ \\sum_{1 \\leq i &lt; j &lt; k \\leq n} |A_i \\cap A_j \\cap A_k| - \\cdots + (-1)^{n-1} |A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$","text":"表达式容斥原理$$ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1}|A_i|- \\sum_{1 \\leq i &lt; j \\leq n}|A_i \\cap A_j|+\\\\ \\sum_{1 \\leq i &lt; j &lt; k \\leq n}|A_i \\cap A_j \\cap A_k| - \\cdots +(-1)^{n-1}|A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$$$ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1} |A_i| - \\sum_{1 \\leq i &lt; j \\leq n} |A_i \\cap A_j|+ \\sum_{1 \\leq i &lt; j &lt; k \\leq n} |A_i \\cap A_j \\cap A_k| - \\cdots + (-1)^{n-1} |A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$ 逐步淘汰原理（筛法公式）$$ | \\complement_S A_1 \\cap \\complement_S A_2 \\cap \\cdots \\cap \\complement_S A_n| = |S|-\\sum^n_{i=1}|A_i|+ \\sum_{1 \\leq i &lt; j \\leq n}|A_i \\cap A_j|-\\\\ \\sum_{1 \\leq i &lt; j &lt; k \\leq n}|A_i \\cap A_j \\cap A_k| + \\cdots +(-1)^n|A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$ 容斥原理与求和及差分以二维求和为例$$ \\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}=\\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[i\\neq n \\lor j\\neq m]+x_{n,m} \\\\ = \\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[i\\neq n]+\\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[j\\neq m] -\\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[i\\neq n \\land j\\neq m]+x_{i,j} $$","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"}]},{"title":"dsu on tree","slug":"dsu-on-tree","date":"2018-05-20T11:24:02.000Z","updated":"2018-05-20T11:24:02.452Z","comments":true,"path":"dsu-on-tree/","link":"","permalink":"http://x.phoenixgs.cn/dsu-on-tree/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"Hello-World","date":"2016-05-29T03:07:22.000Z","updated":"2018-04-09T16:28:03.783Z","comments":true,"path":"Hello-World/","link":"","permalink":"http://x.phoenixgs.cn/Hello-World/","excerpt":"","text":"123456789#include &lt;cstdio&gt;int main()&#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", x + y); return 0;&#125;","categories":[],"tags":[]}]}