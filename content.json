{"pages":[{"title":"TodoList","text":"Things:Done Things:Doing Things:Skip Content State Killed Date 容斥及反演 Doing 二进制分组 动态规划优化 树形DP 动态DP 最小表示 回文自动机 Minmax 反演 弦图 类欧几里得 DP 字符串的最小表示 斯特林数 任意模数NTT 网络流24题 Min_25筛 Done 2018.11.30 后缀自动机 Done 2018.12.27 FFT &amp; NTT Done 2018.12.27 二项式系数 Done 2018.12.29","link":"/todolist/index.html"},{"title":"About","text":"我是一个\b智障 博客经常会进行增添和修改，但我也不知道该怎么搞更新日期。。。 所以看过的文章也可以再看一遍（大雾 如果发现我的博客中出现了错误，请务必联系我 QQ:1637281495 Telegram:@PhoenixGS Mail:thestarrydream@gmail.com","link":"/about/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"CDQ分治与点分治的碰撞","text":"看到了[Noi2014]购票这道题目，发现了这种操作（为什么之前没想到呢。。。） 代码还没写过，先口胡一下 有根树上的DP，每个点只能从祖先转移。 那么考虑点分治 选出一个联通块的重心root之后，以root为根，有若干棵子树。找到root的父亲所在的子树，先递归更新这棵子树。然后再用这棵子树中root的所有祖先来更新root以及其他子树 大概就是这个意思 不过应该也不只局限于DP，但是这些问题有一些限制： 贡献的计算必须是与祖先有关的。如果贡献里有两个点产生贡献但是没有一个点是另外一个点的祖先，那么应该就不能做了吧。（因为这样的话就还要计算不含root的父亲的子树之间产生的贡献了）","link":"/CDQ分治与点分治的碰撞/"},{"title":"64位模数乘法","text":"当模数是一个64位的整数时，乘法取模过程中就会溢出。 此时有两种解决方法 一种是采取与快速幂类似的思想，时间复杂度位$O(lg)$ 12345678910111213141516long long mul(long long x, long long y, long long M){ y = (y % M + M) % M; long long ans = 0; long long tmp = x; while (y) { if (y &amp; 1) { ans = (ans + tmp) % M; } tmp = (tmp + tmp) % M; y &gt;&gt;= 1; } return ans;} 还有一种是利用long double来进行运算，有可能会计算错误，但时间复杂度是$O(1)$的 1234long long mul(long long x, long long y, long long M){ return (x * y - (long long)((long double)x / M * y) * M + M) % M;} 看起来很奇妙是不是？。。。玄学的一匹 摘自2009年国家集训队论文，骆可强：《论程序底层优化的一些方法与技巧》","link":"/64位模数乘法/"},{"title":"FFT与NTT","text":"快速傅立叶变换 FFT对于两个多项式 $$A(x)=\\sum_{i=0}^{N-1}a_ix^i$$ $$B(x)=\\sum_{i=0}^{N-1}b_ix^i$$ FFT可以在$O(nlgn)$的时间内求出 $$C(x)=A(x)*B(x)=\\sum_{i=0}^{2(N-1)}c_ix^i$$ 其中$c_i=\\sum_{j=0}^ia_jb_{i-j}$ 前置知识在复数域下，方程$x^n=1$有$n$个解$\\omega_N^i,(i=1\\dots N)$ 其中 $$\\omega_N^i=(\\cos\\frac{2\\pi i}{N}, \\sin\\frac{2\\pi i}{N})$$ 可以看作是平面直角坐标系中单位圆上间距相等的$N$个点 然后可以自己去学习一下复数)一下qwq 假如把复数用极坐标表示 $z=r(\\cos \\varphi+i\\sin \\varphi)$ 那么复数的乘法就是模长($r$)相乘，幅角($\\varphi$)相加 单位根有如下性质： $$\\omega_N^i\\omega_N^j=\\omega_N^{i+j}$$ $$\\omega_N^i=\\omega_N^{N+i}$$ $$\\omega_N^{\\frac{N}{2}}=-1$$ $$\\omega_N^i=\\omega_{cN}^{ci}$$ DFT我们尝试将$N$下的单位根代入多项式得到$N$个值 也就是 $$F:{a_0,a_1,\\dots a_{N-1}} \\to {A(\\omega_0),A(\\omega_1),\\dots A(\\omega_{N-1})}$$ 显然，可以在$A,B$中补$0$使得$N=2^k(k\\in \\mathbb{N})$ 考虑分治 对于$0\\leq i &lt; \\frac{N}{2}$ 有 $$\\begin{aligned}A_i&amp;=\\sum_{j=0}^{N-1}a_j\\omega_N^{ij}\\\\A_{i+\\frac{N}{2}}&amp;=\\sum_{j=0}^{N-1}a_j\\omega_N^{(i+\\frac{N}{2})j}=\\sum_{j=0}^{N-1}(-1)^ja_j\\omega_N^{ij}\\end{aligned}$$ 将$\\sum$中的奇偶项分开来 $$\\begin{aligned}A_i&amp;=\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j}\\omega_{\\frac{N}{2}}^{ij}+\\omega_N^i\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j+1}\\omega_{\\frac{N}{2}}^{ij}\\\\A_{i+\\frac{N}{2}}&amp;=\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j}\\omega_{\\frac{N}{2}}^{ij}-\\omega_N^i\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j+1}\\omega_{\\frac{N}{2}}^{ij}\\end{aligned}$$ 非常奇妙是不是？这样就可以分治下去啦 IDFT与DFT类似 只不过将DFT中的每个$\\omega$都变成$\\omega^{-1}$，然后最后每个$A_i$都除以$N$ 代入进去显然可以发现是对的。 如果要严格说明是唯一的话就要用线性代数中的Vandermonde矩阵了。。 这里就不写了，感兴趣的可以去了解一下，《算法导论》里讲的也挺详细的 例题来自衲姐NiroBC的例题（Orz） 给一个$N$位的$B$进制数$A$，将它转为十进制。($N,B\\leq 10^5$) 考虑分治 对于$N$位的$B$进制数， 设$M=2^k\\leq \\frac{N}{2}$ 假如我们已经求出了$\\sum_{i=0}^{M-1}A_iB^i$的十进制数以及$\\sum_{i=0}^{N-M-1}A_{i+M}B^i$的十进制数 那么就可以用FFT将$\\sum_{i=0}^{N-M-1}A_{i+M}B^i$乘上$B^M$ 其中$B^M$的十进制数也可以用FFT预处理 时间复杂度为$O(nlg^2n)$ 快速数论变换 NTTNTT与FFT大体上十分相似 主要是因为FFT涉及许多实数运算，因此很容易丢精 当需要对所求的多项式对$M$取模时，NTT就是一个非常好的选择 欧拉定理)：若$n,a$为正整数，且$n,a$互素（即$\\gcd(a,n)=1$），则$$a^{\\varphi(n)}\\equiv 1 \\quad (mod\\; n)$$ NTT一般用于$M$是质数的情况，因此在这里费马小定理： 费马小定理：假如$a$是一个整数，$p$是一个质数$$a^{p-1}\\equiv 1 \\quad (mod\\; p)$$ 原根$G$，满足集合${G^0, G^1, G^2, \\cdots, G^{\\varphi(M) - 1}}$中含有了所有与$M$互质的数。 若$M$可以表示成$2^k*t+1$， 其中$t$是奇数 那么对于小于$2^k$的$N$，$G^{\\frac{M-1}{N}}$都可以作为单位元$w$，其他就和FFT没什么区别了 参考资料 http://nirobc.com/20181205.pdf http://nirobc.com/20181212.pdf http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform","link":"/FFT与NTT/"},{"title":"dsu on tree","text":"","link":"/dsu-on-tree/"},{"title":"微积分","text":"常用的导数$$(C)’=0$$ $$(x^{\\mu})’=\\mu x^{\\mu - 1}$$ $$(\\sin x)’=\\cos x$$ $$(\\cos x)’=-\\sin x$$ $$(\\tan x)’=\\sec ^2 x$$ $$(a^x)’=a^x \\ln a$$ $$(e^x)’=e^x$$ $$(\\log_a x)’=\\frac{1}{x ln a}$$ $$(\\ln x)’=\\frac{1}{x}$$ 链式法则若$h(a)=f[g(x)]$ 则$h’(a)=f’[g(x)]g’(x)$","link":"/Calculus/"},{"title":"Min_25筛","text":"简介Min_25筛用来求一个函数的前缀和 如果函数是积性函数就可以做，如果不是积性函数的话有一部分也是可以做的 算法过程就像是在模拟埃氏筛法 时间复杂度是$O(\\frac{n^{\\frac{3}{4}}}{log(\\sqrt{n})})$，然而我并不会证 算法质数的函数值的前缀和设$m(x)$表示$x$的最小质因子 假如要求 $$\\sum_{i = 1}^{n}f(i)[i是质数]$$ 首先将$\\sqrt{n}$之内的质数全部筛出来，放在prime数组里 设 $$g(n,j)=\\sum_{i = 2}^{n}f(i)[m(i) &gt; prime_j 或 i 是质数]$$ 那么 $$g(n,j) = \\begin{cases} g(n,j - 1) - f(j)[g(\\lfloor \\frac{n}{prime_j} \\rfloor, j - 1) - g(prime_{j - 1}, j - 1)] &amp; prime_j^2 \\leq n \\\\ g(n,j - 1) &amp; prime_j^2 &gt; n\\end{cases}$$ 显然，其中的$g(prime_{j-1},j-1)=\\sum_{i=1}^{j-1}f(prime_i)$ 那么原式中第一维有用的值只有$O(\\sqrt{n})$种，预处理即可 最终$g(n,primenum)$就是我们要求的$\\sum_{i = 1}^{n}f(i)[i是质数]$ 关于$f(x)$如果只求质数的函数值的话， $f(x)$应该满足下面几个条件： 若$x$是质数$f(x)$应该要能在$O(1)$内求出来 要能够快速求出$\\sum_{i=2}^{n}f’(i)$，其中$f’(i)=\\Pi_{j,k}f(j)[k &gt; 0][j^k|n]$ 函数值的前缀和递归版假设我们要求的函数是$f(x)$，那么问题就是求 $$\\sum_{i = 1}^{n}f(i)$$ 之前已经求出了 $$\\sum_{i = 1}^{n}f(i)[i是质数]$$ 的值 那么，现在设 $$h(n,j) = \\sum_{i=2}^nf(i)[m(i) \\geq prime_j]$$ 那么 $$h(n,j)=g(n,primenum) - g(prime_{i-1},i-1)+\\\\\\sum_{i=j}^{primenum}\\sum_{e\\geq 1 且 prime_i^{e+1}\\leq n}f(prime_i^e)h(\\lfloor \\frac{n}{prime_i^e} \\rfloor,i+1)+f(prime_i^{e+1})$$ 和上面一样，第一维有用的取值只有$O(\\sqrt{n})$种 写一个递归函数，最后的答案即为$h(n,1)+f(1)$ 假如就询问没几个$n$的答案，就可以用这种方法 非递归版这次改变一下状态 设 $$h(n,j)=\\sum_{i=2}^nf(i)[m(i)\\geq prime_j 或 i是质数]$$ 那么 $$h(n,j)=\\begin{cases} h(n,j+1)+\\ \\sum_{e \\geq 1 且prime_j^{e+1}\\leq n}f(prime_j^e)[h(\\lfloor \\frac{n}{prime_j^e} \\rfloor,j + 1) - g(prime_i,i)] &amp; prime_j^2 \\leq n \\\\ h(n,j+1) &amp; prime_j^2 &gt; n\\end{cases}$$ 有没有发现这个式子与质数函数值的前缀和的式子特别像？只不过质数一个是从小枚举到大，一个是从大枚举到小 答案为$h(n,1)+f(1)$ 假如要询问许多$n’= \\lfloor \\frac{n}{x} \\rfloor$的答案，就可以用这种方法 关于$f(x)$$f(x)$函数如果是积性函数，那么应该都可以做 假如不是的话，首先要满足求质数的函数值的前缀和的那些条件 并且若$x=ab,gcd(a,b)=1$，$f(x)$能$O(1)$从$f(a)$和$f(b)$合并，那么应该就能做了（其实我也不是很清楚qaq 关于时间复杂度暂时还不会。。。 参考资料 http://www.cnblogs.com/zzqsblog/p/8302815.html http://www.hekai.site/wordpress/2018/09/04/min_25%E7%AD%9B/ https://blog.csdn.net/XianHaoMing/article/details/80397777 https://www.cnblogs.com/Menhera/p/9226649.html https://blog.csdn.net/ZLTJohn/article/details/79703503","link":"/Min-25/"},{"title":"Hello World","text":"123456789#include &lt;cstdio&gt;int main(){ int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", x + y); return 0;}","link":"/Hello-World/"},{"title":"Prufer序","text":"Prufer序一个Prufer数列和一个带编号的无根树是一一对应的 树-&gt;Prufer序每次找这棵树中编号最小的叶子节点，将与这个点相连的点加入Prufer序，去掉这个点以及相连的边。重复这个操作直到剩下两个点。 Prufer序-&gt;树设点集$ V={1,2,…,n} $，每次在$V$中找出最小的未在Prufer序中出现过的数，然后在$V$中删除，与Prufer序中的第一个数相连，Prufer序中的第一个数删除。重复这个操作直到$|V|=2$（Prufer序为空），最后将$V$中的两个点相连。 证明这个感性理解一下感觉很有道理的 注意到，如果一个节点A不是叶子节点，那么它至少有两条边；但在上述过程结束后，整个图只剩下一条边，因此节点A的至少一个相邻节点被去掉过，节点A的编号将会在这棵树对应的Prüfer编码中出现。反过来，在Prüfer编码中出现过的数字显然不可能是这棵树（初始时）的叶子。于是我们看到，没有在Prüfer编码中出现过的数字恰好就是这棵树（初始时）的叶子节点。找出没有出现过的数字中最小的那一个（比如④），它就是与Prüfer编码中第一个数所标识的节点（比如③）相邻的叶子。接下来，我们递归地考虑后面n-3位编码（别忘了编码总长是n-2）：找出除④以外不在后n-3位编码中的最小的数（左图的例子中是⑦），将它连接到整个编码的第2个数所对应的节点上（例子中还是③）。再接下来，找出除④和⑦以外后n-4位编码中最小的不被包含的数，做同样的处理……依次把③⑧②⑤⑥与编码中第3、4、5、6、7位所表示的节点相连。最后，我们还有①和⑨没处理过，直接把它们俩连接起来就行了。由于没处理过的节点数总比剩下的编码长度大2，因此我们总能找到一个最小的没在剩余编码中出现的数，算法总能进行下去。这样，任何一个Prüfer编码都唯一地对应了一棵无根树，有多少个n-2位的Prüfer编码就有多少个带标号的无根树。 ——摘自Matrix67 性质 一棵n个节点的无根树唯一地对应了一个长度为n-2的数列，数列中的每个数都在1到n的范围内。 Prufer序列中某个编号出现的次数就等于这个编号的节点在无根树中的度数-1。 设无根树每个点的度数为$D_i$，则$\\sum_{i=1}^n(D_i-1)=n-2$（这好像是废话，，，因为$\\sum_{i=1}^nD_i=2(n-1)$。。。 Cayley公式Cayley公式一个完全图$K_n$有$n^{n-2}$棵生成树 证明由Prufer可知，一个Prufer数列和一个带编号的无根树是一一对应的，那么这个公式也很显然了。因为$n$个节点的无根树的Prufer序长度为$n-2$，序列中每个值取值为${1,2,3,…,n}$，因此不同的Prufer序有$n^{n-2}$个，因此生成树也有这么多个。 推广n个节点的度依次为$D_1,D_2,…,D_n$的无根树共有$\\frac{(n-2)!}{(D_1-1)!(D_2-1)!\\cdots(D_n-1)!}$个。 例题BZOJ1005 LOJ6395 https://www.cnblogs.com/onioncyc/p/9052946.html 参考资料http://www.matrix67.com/blog/archives/682 https://www.cnblogs.com/dirge/p/5503289.html","link":"/Prufer/"},{"title":"一个关于整值函数的结论","text":"结论设$f(x)$是任意一个具有如下性质且在一个实数区间连续的单调递增函数且 $$f(x)=整数\\to x=整数 $$ 只要$f(x),f(\\lfloor x \\rfloor), f(\\lceil x \\rceil)$有定义，那么就有 $$f(\\lfloor x \\rfloor)=\\lfloor f(\\lfloor x \\rfloor) \\rfloor 和 f(\\lceil x \\rceil)=\\lceil f(\\lceil x \\rceil) \\rceil$$ 证明此处证明底函数的情况，顶函数类似 若$x$为整数，那么结论显然成立 否则，$x$不为整数，那么就有$\\lfloor x \\rfloor&lt;x&lt;\\lceil x\\rceil$，那么$f(\\lfloor x\\rfloor)&lt;f(x)$ 也就是说$\\lfloor f(\\lfloor x \\rfloor)\\rfloor \\leq \\lfloor f(x)\\rfloor$ 若$\\lfloor f(\\lfloor x \\rfloor)\\rfloor &lt; \\lfloor f(x)\\rfloor$，那么$f(\\lfloor x\\rfloor)&lt;\\lfloor f(x)\\rfloor\\leq f(x)$ 那么就存在一个$y$使得$\\lfloor x\\rfloor&lt;y\\leq x$且$f(y)=\\lfloor f(x)\\rfloor$ 由函数的性质可知$y$是一个整数。又因为$x$不是整数，因此$x&lt; \\lceil x\\rceil$，所以$\\lfloor x\\rfloor &lt; y &lt; \\lceil x\\rceil$，但是不存在这样的整数。因此$\\lfloor f(x)\\rfloor = \\lfloor f(\\lfloor x \\rfloor)\\rfloor$ 推论$\\alpha$如果$m$是整数且$n$是正整数，那么 $$\\lfloor \\frac{x+m}{n}\\rfloor=\\lfloor\\frac{\\lfloor x\\rfloor+m}{n}\\rfloor和\\lceil \\frac{x+m}{n}\\rceil=\\lceil\\frac{\\lceil x\\rceil+m}{n}\\rceil$$ 利用上面的结论证明显然 推论$\\beta$如果$y,z$是正整数，那么 $$\\lfloor\\frac{\\frac{x}{y}}{z}\\rfloor=\\lfloor\\frac{\\lfloor\\frac{x}{y}\\rfloor}{z}\\rfloor和\\lceil\\frac{\\frac{x}{y}}{z}\\rceil=\\lceil\\frac{\\lceil\\frac{x}{y}\\rceil}{z}\\rceil$$ 利用推论$\\alpha$证明显然 参考资料 《具体数学（中文第二版）》3.2节","link":"/一个关于整值函数的结论/"},{"title":"反演","text":"反演的本质对于可逆下三角矩阵$A$（可以归纳证明$A^{-1}$也是下三角矩阵）,有$f=Ag$,那么$g=A^{-1}f$ 即: $$f_i=\\sum_{j=0}^ia_{ij}g_j\\Rightarrow g_i=\\sum_{j=0}^ib_{ij}f_j$$ 其中:$$\\sum_{k=0}^na_{ik}b_{kj}=[i==j]$$ 几类特殊的反演前缀和及差分如果$f$是$g$的前缀和,那么: $$f_i=\\sum_{j=0}^ig_j$$ $g$即为$f$的差分: $$g_i=f_i-f_{i-1}[i &gt; 0]$$ 那么$A$即为: $$ A = \\begin{bmatrix} 1 \\\\ 1 &amp; 1 \\\\ \\vdots &amp; \\vdots &amp; \\ddots \\\\ 1 &amp; 1 &amp; \\cdots &amp; 1 \\end{bmatrix}$$ $A$的逆矩阵: $$ A^{-1}=\\begin{bmatrix} 1 \\\\ -1 &amp; 1 \\\\ &amp; -1 &amp; \\ddots \\\\ &amp; &amp; \\ddots &amp; 1 \\\\ &amp; &amp; &amp; -1 &amp; 1 \\end{bmatrix}$$ 高阶前缀和及差分很容易想到,$k$阶前缀和及差分的矩阵即为$1$阶的矩阵的$k$次: $$ A=\\begin{bmatrix} 1 \\\\ 1 &amp; 1 \\\\ \\vdots &amp; \\vdots &amp; \\ddots \\\\ 1 &amp; 1 &amp; \\cdots &amp; 1 \\end{bmatrix}^k$$ 其中: $$a_{ij}=\\binom{k-1+i-j}{i-j}$$ 这个其实非常容易感性理解吧。。画个图，然后类似于算路径数 那么$A^{-1}$呢 $$ A^{-1}=\\begin{bmatrix} 1 \\\\ -1 &amp; 1 \\\\ &amp; -1 &amp; \\ddots \\\\ &amp; &amp; \\ddots &amp; 1 \\\\ &amp; &amp; &amp; -1 &amp; 1 \\end{bmatrix}^k$$ 其中: $$(a^{-1})_{ij}=(-1)^{i-j}\\binom{k}{i-j}=\\binom{-k-1+i-j}{i-j}$$ 和上面那个十分得神似。 二项式反演二项式反演有两种形式 $$f_i=\\sum_{j=0}^i\\binom{i}{j}g_j\\Rightarrow g_i=\\sum_{j=0}^i(-1)^{j-i}\\binom{i}{j}f_j\\tag{1}$$ $$f_i=\\sum_{j=0}^{i}(-1)^j\\binom{i}{j}g_j\\Rightarrow g_i=\\sum_{j=0}^i(-1)^j\\binom{i}{j}f_j\\tag{2}$$","link":"/反演/"},{"title":"密码Hello","text":"Hello Incorrect Password! No content to display! U2FsdGVkX187ciNpoQtLsvnuyR0QnLcNydnWNx8s2356YAgPIsE/BxnNhiXTgN9rSsadeVHxW3AbBk91oaqCbrkuNsuAaloe9WwUoRm545cYF5sbBdTn77O/Z7sYvDWnnG2sKDjmfJZgDU4s9fBnwbF4puBwPmFqP18wm8xl456QZojqTpV2jm2JALPiMf6/LghiyJBDa+lFV0CnOmNngNMJt39jW7MjFb0F8MK/I+x+flw5YBVlMYjPaK6uGDWK+CQxrLWuH+01kh4Ns/Lq09M1UaKLDfZF3hibhhrx+B7dUpvbMhd1GOIZLfzNDfDKoK2KTd7ag9qJ126DSvuOAeaifnlfNJyyp6gyGpwfLbf1fCEONmdwkdIDGFFX/LLC+isM5r5mf/zqjYKRzbck5XM6sip08CJ0AY7Q9hZqQgXSu7i5x+iIEOsd27kfCgBsrmZZr2Zeq/h1tZmjsdxOMB0GL4YSbOySRfEjZtoVqgvOVO/VwjXTXXznnr8BOxSBb+EO8FTSW/p5JSEcxc4V5uAr7XuuDiYc0VwTbCthPFz/mOitfXzxjqLhMNfztPr8BBOr/DvUfUhI4GUCp1DXDdjKQQely/O02Zt8g+GHgWvpI8dI/u/gfVgXlSJdFrwujFo8COqGxcqQV5jpBP96YNFU0y2D9I7CVqME/s5mCs0XkMPH+gTocil+HHtLYzMjfOM5ZisNeFhpCGl1fExI1B0D5lVUo4QvFXwjMq+QqAVrafEZlMtc6TADumS36Q4ixUME3iKYVOHdT0b9bRMX1Ld/g/h84hth3sRV1ItsoGuii8++eJkYD3VjooPLzoD8wT3TvtqOkcd7dpCLM7omgy9K1xCtE4KL1v/D4LhG1HgItrq0UDe/WbD6UMjuO91Hd9LMBUyW5oXiU582iQQbfMLIAu7XnH2P4SaAu1mopXYuttLtDD2+yScihQLDiZbi7BAX06cpuJoTiLzNHqk6Eac2guYCP1SZ9/qC+qhOY2kjKoWfbTye16vlyWmORXYIOnBe63SqRCf7PWN7ruRjHPsyz7Uvop4wST1NZ7BhQO8=","link":"/密码Hello/"},{"title":"容斥原理","text":"表达式容斥原理$$ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1}|A_i|- \\sum_{1 \\leq i &lt; j \\leq n}|A_i \\cap A_j|+\\ \\sum_{1 \\leq i &lt; j &lt; k \\leq n}|A_i \\cap A_j \\cap A_k| - \\cdots +(-1)^{n-1}|A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$ 逐步淘汰原理（筛法公式）$$ | \\complement_S A_1 \\cap \\complement_S A_2 \\cap \\cdots \\cap \\complement_S A_n| = |S|-\\sum^n_{i=1}|A_i|+ \\sum_{1 \\leq i &lt; j \\leq n}|A_i \\cap A_j|-\\ \\sum_{1 \\leq i &lt; j &lt; k \\leq n}|A_i \\cap A_j \\cap A_k| + \\cdots +(-1)^n|A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$ 容斥原理与求和及差分以二维求和为例$$ \\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}=\\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[i\\neq n \\lor j\\neq m]+x_{n,m} \\ = \\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[i\\neq n]+\\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[j\\neq m] -\\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[i\\neq n \\land j\\neq m]+x_{i,j} $$","link":"/容斥原理/"},{"title":"多项式求逆","text":"定义我们说$B(x)$是$A(x)$在模$x^n$意义下的逆元则是满足 $$A(x)*B(x)\\equiv1(mod \\; x^n)$$ 分治考虑分治 假如我们已经知道在模$x^{\\lceil \\frac{n}{2} \\rceil}$下$A$的逆$B’$ 即 $$A(x)*B’(x)\\equiv 1(mod \\; x^{\\lceil \\frac{n}{2} \\rceil})$$ $$A(x)*B’(x)-1\\equiv 0(mod \\; x^{\\lceil \\frac{n}{2} \\rceil})$$ 两边平方即可得 $$(A(x)*B’(x)-1)^2\\equiv 0(mod \\; x^{2\\lceil \\frac{n}{2} \\rceil})$$ \b显然$2\\lceil \\frac{n}{2} \\rceil \\geq n$ 所以 $$(A(x)*B’(x)-1)^2\\equiv 0(mod \\; x^n)$$ $$A^2(x)B’^2(x)-2A(x)B’(x)+1\\equiv 0(mod \\; x^n)$$ $$2A(x)B’(x)-A^2(x)B’^2(x)\\equiv 1(mod \\; x^n)$$ $$A(x)(2B’(x)-A(x)*B’^2(x))\\equiv 1(mod \\; x^n)$$ 那么$B(x)=2B’(x)-A(x)B’^2(x)$即为满足$A(x)B(x)\\equiv 1(mod \\; x^n)$的$B(x)$ 参考资料 http://nirobc.com/20181212.pdf https://www.cnblogs.com/yoyoball/p/8724115.html","link":"/多项式求逆/"},{"title":"数论中的一些常用结论","text":"","link":"/数论中的一些常用结论/"},{"title":"更新主题","text":"今天突然发现icarus主题不知道什么时候更新了 搞了一会儿更新好了，感觉好看了不少 前后对比图：","link":"/更新主题/"},{"title":"后缀自动机","text":"SAM关于后缀自动机整个算法，在这了就不多说了，感觉别人写的都很好QAQ 可以去看看参考资料里的几篇文章，感觉学过OI的应该都能看懂。。 在这里我就写一下自己的理解和一些性质和应用 我的模版1234567891011121314151617181920212223242526272829303132333435363738394041424344void extend(int c){ knum++; int u = last; int v = knum; last = knum; len[v] = len[u] + 1; for (; u &amp;&amp; ! to[u][c]; u = pre[u]) { to[u][c] = v; } if (! u) { pre[v] = root; return; } int w = to[u][c]; if (len[u] + 1 == len[w]) { pre[v] = w; return; } knum++; int neww = knum; pre[neww] = pre[w]; len[neww] = len[u] + 1; for (int i = 0; i &lt; 26; i++) { to[neww][i] = to[w][i]; } pre[w] = pre[v] = neww; for (; u &amp;&amp; to[u][c] == w; u = pre[u]) { to[u][kkc] = neww; }}int main(){ //init last = 1; knum = 1; root = 1;} 时间复杂度状态数状态数是$O(n)$的，这十分显然。 每个状态按照pre边连接可以变成一棵树。 父子节点集合关系是包含的 兄弟节点集合关系是无交的 所以脑补一下，就可以发现状态个数最多就是二叉树的时候，也就只有$2n-1$。。。 转移数首先，一个十分显然的结论是，转移数最多为$O(\\Sigma * n)$，其中$\\Sigma$表示字符集大小 有一个更加紧的上限： $$3n-4\\; (对于n\\geq 3)$$ 然后，考虑以下的事实： 初始节点开始的最长的转移路径树 节点数为$2n-1$，那么边数即为$2n-2$ 考虑不在这棵树中的转移$u\\to v$，字符为$y$ 那么初始节点到$u$的字典序最大字符串（最小应该也行，只要保证唯一）$x$，以及$v$到任意一个终止节点的最长字符串（同样也可以是最小）$z$。 $x+y+z$即为原串的一个后缀，后缀只有$n-1$个，（原串这个后缀肯定在刚开始的树上）。 因此转移数的上限即为$3n-4$ 能达到上限的字符串 $$abb \\dots bc$$ 修改to的次数从上面的模版可以看出，现在除了 1234for (; u &amp;&amp; to[u][c] == w; u = pre[u]){ to[u][kkc] = neww;} 这一段之外时间复杂度就是$O(n)$ 那么，这一段的总共的时间复杂度是多少呢？ 定义$minlen(u)$表示为能走到$u$的所有字符串的最小长度 显然$minlen$有一个性质： $$minlen(u)&gt;minlen(pre[u])&gt;minlen(pre[pre[u]])\\cdots &gt; minlen(root) \\quad (*)$$ 那么考虑$minlen(pre[last])$这个东西 如果执行到了这个for循环，那么$pre[last]$就变成了$neww$ 可以发现这个for循环如果循环了$k$次 那么$minlen(neww)\\leq minlen(lastu)+1$，其中$lastu$是for循环枚举的最后的$u$ 通过$(*)$可以知道$minlen(lastu)\\leq minlen(pre[last])-k$ 那么$minlen(pre[neww])\\leq minlen(pre[last])-k+1$ 其中$+1$最多加$n$次，$minlen(pre[last])$的初值为$0$ 从而for循环执行的次数是$O(n)$的 总结从上面三部分可知，构建后缀自动机的的时间复杂度为$O(n)$ 如果有不懂的欢迎打扰 如果有哪位大佬能想出更好的证明方法的话，请务必告诉我QAQ 一些性质及应用 后缀自动机每个节点的状态为：后面还要输入哪些串就是一个后缀 对于后缀自动机中每个节点所表示的字符串（起点到这个节点的所有字符串），是在原串中出现位置一模一样的所有字符串。按照长度排序后，是长度依次减一并且是前一个的后缀。比如：$abcac, bcac, cac$ 一个节点沿着pre一直走到起始节点的所有节点所表示的所有字符串，正好是最长的字符串的所有后缀 本质不同的字串个数答案显然是$\\sum_u len[u] - len[pre[u]]$ 字符串循环移位的最小表示求$S$的循环移位的最小表示 将$S+S$建一个后缀自动机 然后从起始节点开始贪心每次选最小的出边，选择$|S|$次后得到的字符串就是最小表示 求$right$集合可以在每次extend之后令size[last] = 1，然后按照pre边可以求出每个状态$right$集合的大小 如果只是想单纯地输出每个状态的集合的话，可以直接沿着pre边的反向边求出$right$集合。因为前面也已经说过，走到的状态数最多只有$2|right|-1$个 当然也可以利用线段树合并搞出每个状态具体的$right$集合，这样就会多一个$log$ 用拓扑排序的写法写起来比较简单，也可以用DFS 求两个串的最长公共子串求$S$和$T$的最长公共子串 可以先对$S$建一个后缀自动机 然后拿$T$在自动机上跑，如果有转移则转，没有转移就沿着pre向上跳（话说这不是自动机的基本操作吗。。。） 每次转移后拿len更新答案 推广：广义后缀自动机说是广义，其实就是建多个串$S_i$的后缀自动机。。。 那么应该怎么建呢？ 一种十分简单粗暴的方法就是将$S_1+’ #’+S_2+’ #’+\\cdots +’ #’+S_k$建后缀自动机 还有一种方法，就是将原来的模版改成这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void extend(int c){ int u = last; if (to[u][c]) { int w = to[u][c]; if (len[u] + 1 == len[w]) { return w; } knum++; int neww = knum; pre[neww] = pre[w]; for (int i = 0; i &lt; s; i++) { to[neww][i] = to[w][i]; } len[neww] = len[u] + 1; pre[w] = neww; for (; u &amp;&amp; to[u][c] == w; u = pre[u]) { to[u][c] = neww; } return neww; } knum++; int v = knum; last = knum; len[v] = len[u] + 1; for (; u &amp;&amp; ! to[u][c]; u = pre[u]) { to[u][c] = v; } if (! u) { pre[v] = root; return; } int w = to[u][c]; if (len[u] + 1 == len[w]) { pre[v] = w; return; } knum++; int neww = knum; pre[neww] = pre[w]; len[neww] = len[u] + 1; for (int i = 0; i &lt; 26; i++) { to[neww][i] = to[w][i]; } pre[w] = pre[v] = neww; for (; u &amp;&amp; to[u][c] == w; u = pre[u]) { to[u][kkc] = neww; }}int main(){ //init last = 1; knum = 1; root = 1; for (int i ; ;) { //add Si last = root; }} 每次添加完一个字符串后将last赋为root就行了 参考资料 http://nirobc.com/20181224.pdf https://oi-wiki.org/string/sam/ https://blog.csdn.net/qq_35649707/article/details/66473069","link":"/后缀自动机/"},{"title":"概率论","text":"概念 样本空间：一个随机试验的所有可能结果组成的集合，标记为$S$ 事件：$S$的一个子集$A$，$A\\subseteq \\Omega$，称为事件 概率公理 $0\\leq P(A)\\leq 1$ $P(\\Omega)=1$ 如果$A_1A_2A_3\\cdots$是一系列两两无关的事件，即对于任何$i,j,i\\neq j,A_i\\cap A_j=\\phi$，则 $$P\\lgroup \\bigcup_{k=1}^{\\infty} A_k \\rgroup=\\sum_{k=1}^{\\infty}P(A_k)$$ 条件概率令$B$为一个事件满足$P(B)&gt;0$，对于任意事件$A$，定义$A$的关于$B$的条件概率。$$P(A|B)=\\frac{P(A\\cap B)}{P(B)}$$ 独立如果$A,B$满足$P(A\\cap B)=P(A)P(B)$，称$A,B$独立。并且可以推出$P(A)=P(A|B)$ 性质 概率的加法公式 $$P(A\\cup B)=P(A)+P(B)-P(A\\cap B)$$ 并的界 $$P(A\\cup B)\\leq P(A)+P(B)$$ 全概率公式 设$B_1B_2B_3\\cdots B_n$是样本空间$S$中互不相交的一系列事件，并且满足$S=\\bigcup_{k=1}^n B_k$，那么对于任意事件$A$ $$P(A)=\\sum_{k=1}^nP(A|B_k)P(B_k)$$ 平均值均值$$\\sum_{x\\in X(\\Omega)}x\\cdot Pr(X=x)$$ 也就是期望值 中位数满足 $$Pr(X\\leq x) \\geq \\frac{1}{2}且Pr(X\\geq x) \\geq \\frac{1}{2}$$ 的所有$x\\in X(\\Omega)$组成的集合 众数满足 $$Pr(X = x) \\geq Pr(X=x^{‘}), \\forall x^{‘}\\in X(\\Omega)$$ 的所有$x\\in X(\\Omega)$组成的集合 期望$$EX=\\sum_{\\omega \\in \\Omega}X(\\omega)Pr(\\omega)$$ 性质$$E(X+Y)=\\sum_{\\omega \\in \\Omega}(X(\\omega)+Y(\\omega))Pr(\\omega)=EX+EY$$ $$E(\\alpha X)=\\alpha EX$$ $$E(XY)=(EX)(EY),如果X和Y是独立的$$ 方差$$VX=E((X-EX)^2)$$ 标准差$$\\sigma=\\sqrt{VX}$$ 性质因为$(EX)$是常数， $$\\begin{array}{l}VX\\\\=E((X-EX)^2)\\\\=E(X^2-2X(EX)+(EX)^2)\\\\=E(X^2)-2(EX)(EX)+(EX)^2\\\\=E(X^2)-(EX)^2\\end{array}$$ 当$X$和$Y$为独立的随机变量时， $$\\begin{array}{l}V(X+Y)\\\\=E((X+Y)^2)-(EX+EY)^2\\\\=E(X^2)+2(EX)(EY)+E(Y^2)-(EX)^2-2(EX)(EY)-(EY)^2\\\\=E(X^2)-(EX)^2+E(Y^2)-(EY)^2\\\\=VX+VY\\end{array}$$ 整数概率公式$$E(x)=\\sum_{i=1}^{\\infty}P(x\\geq i)$$ 正整数随机变量的期望等于其分别大于等于所有数的概率之和 证明$$E(x)=\\sum_{i=1}^{\\infty}iP(x=i)=\\sum_{i=1}^{\\infty}i[P(x\\geq i)-P(x\\geq i+1)]=\\sum_{i=1}^{\\infty}P(x\\geq i)$$","link":"/概率论/"},{"title":"线性基","text":"简介设数集$T$，$T$的线性基为最小的一个集合$S$，$S$与$T$通过异或运算能产生的集合相同，也就是$S$是$T$的线性无关极大子集 性质 线性基的异或集合中每个元素的异或方案唯一 线性基二进制最高位互不相同 维护插入123456789101112131415161718void insert(long long x){ for (int i = 60; i &gt;= 0; i--) { if ((1ll &lt;&lt; i) &amp; x) { if (v[i]) { x = x ^ v[i]; } else { v[i] = x; return; } } }} 合并将一个线性基暴力插入到另一个线性基 查询一个数能否被这个线性基表示123456789101112131415161718bool query(long long x){ for (int i = 60; i &gt;= 0; i--) { if ((1ll &lt;&lt; i) &amp; x) { if (v[i]) { x = x ^ v[i]; } else { return false; } } } return true;} 最大值12345678ans = 0;for (int i = 51; i &gt;= 0; i--){ if ((ans ^ v[i]) &gt; ans) { ans = ans ^ v[i]; }} 第k小值123456789101112131415161718192021222324252627282930313233343536373839void build(){ for (int i = 0; i &lt;= 60; i++) { for (int j = i - 1; j &gt;= 0; j--) { if ((1ll &lt;&lt; j) &amp; v[i]) { v[i] ^= v[j]; } } } last = 0; for (int i = 0; i &lt;= 60; i++) { if (v[i]) { vv[last] = v[i]; last++; } }}long long query(long long k){ if (k &gt;= (1ll &lt;&lt; last)) { return (long long)-1; } long long ans = 0; for (int i = 0; i &lt; last; i++) { if ((1ll &lt;&lt; i) &amp; k) { ans = ans ^ vv[i]; } } return ans;} 参考https://blog.csdn.net/qaq__qaq/article/details/53812883","link":"/线性基/"},{"title":"最重要的十个二项式系数恒等式","text":"$$\\binom{n}{k}=\\frac{n!}{k!(n-k)!},整数n\\geq k\\geq 0$$ 阶乘展开式 $$\\binom{n}{k}=\\binom{n}{n-k},整数n\\geq 0,k是整数 $$ 对称恒等式 $$\\binom{r}{k}=\\frac{r}{k}\\binom{r-1}{k-1},整数k\\neq 0$$ 吸收/提取恒等式 $$\\binom{r}{k}=\\binom{r - 1}{k}+\\binom{r - 1}{k - 1},k是整数 $$ 加法/归纳恒等式 $$\\binom{r}{k}=(-1)^k\\binom{k-r-1}{k},k是整数 $$ 上指标反转 $$\\binom{r}{m}\\binom{m}{k}=\\binom{r}{k}\\binom{r-k}{m-k} ,m,k是整数 $$ 三项式版恒等式 $$\\sum_k\\binom{r}{k}x^ky^{r-k}=(x+y)^r,整数r\\geq 0 或者 \\vert x/y \\vert &lt;1 $$ 二项式定理 $$\\sum_{k\\leq n}\\binom{r+k}{k}=\\binom{r+n+1}{n},n是整数 $$ 平行求和法 $$\\sum_{0\\leq k \\leq n}\\binom{k}{m}=\\binom{n+1}{m+1},整数m,n\\geq 0 $$ 上指标求和法 $$\\sum_{k}\\binom{r}{k}\\binom{s}{n-k}=\\binom{r+s}{n},n是整数 $$ 范德蒙德卷积公式 摘自《具体数学》","link":"/最重要的十个二项式系数恒等式/"},{"title":"花里胡哨的二项式系数","text":"跳进了这个坑。。。于是就开始自闭了。 还有许许多多关于二项式系数的东西没有写，以后会补的(?) 二项式系数$$\\binom{n}{m}=\\frac{n!}{m!(n-m)!}$$ 严格一点的定义： $$\\binom{n}{m}=\\begin{cases}\\frac{n!}{m!(n-m)!} &amp; 整数m\\geq 0\\\\0 &amp; 整数m&lt;0\\end{cases}$$ 为什么要叫二项式系数呢？ 因为有一个二项式定理。。 二项式定理：设$n$是正整数。对所有的$x$和$y$，有$$(x+y)^n=\\sum_{k=0}^{n}\\binom{n}{k}x^ky^{n-k}$$ 推广多项式系数（应该是叫这个吧。。）$$\\binom{n}{n_1\\;n_2\\cdots n_t}=\\frac{n!}{n_1!n_2!\\cdots n_t!}$$ 同样，有一个多项式定理： 多项式定理：$$(x_1+x_2+\\cdots+x_t)^n=\\sum\\binom{n}{n_1\\;n_2\\cdots n_t}x_1^{n_1}x_2^{n_2}\\cdots x_t^{n_t}$$ 对实数的推广$$\\binom{r}{k}=\\begin{cases}\\frac{r(r-1)\\cdots(r-k+1)}{k(k-1)\\cdots(1)} &amp; 整数k\\geq 0 \\\\0 &amp; 整数k&lt;0\\end{cases}$$ 因此有了牛顿二项式定理。。 牛顿二项式定理：设$\\alpha$是实数。对于所有满足$0\\leq |x| &lt; |y|$的$x$和$y$，有$$(x+y)^{\\alpha}=\\sum_{k=0}^{\\infty}\\binom{\\alpha}{k}x^ky^{\\alpha - k}$$ 证明去看微积分因为我忘了 若设$z=x/y$，其中$|z|&lt;1$那么 $$(1+z)^{\\alpha}=\\frac{(x+y)^{\\alpha}}{y^{\\alpha}}=\\sum_{k=0}^{\\infty}\\binom{\\alpha}{k}z^k$$ 然后就又出现了一个罪恶的东西：生成函数。。。这里不再展开，以后会另写一篇的（真的不会鸽了吗？） 二项式系数的一些性质在这里规定一下这一段中$r$是实数，$n,m,k$是整数 帕斯卡三角形： n $\\binom{n}{0}$ $\\binom{n}{1}$ $\\binom{n}{2}$ $\\binom{n}{3}$ $\\binom{n}{4}$ $\\binom{n}{5}$ 0 1 1 1 1 2 1 2 1 3 1 3 3 1 4 1 4 6 4 1 5 1 5 10 10 5 1 通过帕斯卡三角形可以发现对称性。证明也十分显然，用定义即可： $$\\binom{n}{k}=\\binom{n}{n-k}, n\\geq 0$$ 下面还有一些重要的恒等式： $$\\binom{r}{k}=\\frac{r}{k}\\binom{r - 1}{k - 1}，k\\neq 0$$ $$k\\binom{r}{k}=r\\binom{r - 1}{k - 1}$$ $$(r-k)\\binom{r}{k}=r\\binom{r - 1}{k}$$ 加法公式: $$\\binom{r}{k}=\\binom{r - 1}{k}+\\binom{r - 1}{k - 1}$$ 现在是两个特殊的对二项式系数的求和公式 $$\\begin{aligned}\\sum_{k\\leq n}\\binom{r+k}{k} &amp; = \\binom{r}{0}+\\binom{r+1}{1}+\\cdots+\\binom{r+n}{n} \\\\&amp;=\\binom{r+n+1}{n}\\end{aligned}$$ $$\\begin{aligned}\\sum_{0\\leq k\\leq n}\\binom{k}{m}&amp;=\\binom{0}{m}+\\binom{1}{m}+\\cdots+\\binom{n}{m}\\\\&amp;=\\binom{n+1}{m+1},m,n\\geq 0\\end{aligned}$$ 对于这两个公式的感性理解，假如其中的数字都是整数的话。 那么可以发现在帕斯卡三角形上都是一个特殊的排列位置。 只要加一个$0$，运用加法公式，那些位置就像多米诺骨牌那样，咕噜咕噜。。。很好理解对吧。。。 二项式定理告诉我们： $$(x+y)^n=\\sum_{k=0}^{n}\\binom{n}{k}x^ky^{n-k}$$ 把$x=y=1$代入，就有： $$2^n=\\sum_{k=0}^n\\binom{n}{k}$$ 把$x=1,y=-1$代入，就有： $$0=\\sum_{k=0}^n(-1)^k\\binom{n}{k}$$ 现在对 $$(1+x)^n=\\sum_{k=0}^n\\binom{n}{k}x^k$$ 求导，就变成了： $$n(1+x)^{n-1}=\\sum_{k=1}^nk\\binom{n}{k}x^{k-1}$$ 如果把$x=1$代入，就会发现： $$1\\binom{n}{1}+2\\binom{n}{2}+\\cdots+n\\binom{n}{n}=n2^{n-1}$$ 上面这个式子其实也可以用$k\\binom{n}{k}=n\\binom{n-1}{k-1}$推导出来 $$\\binom{n_1+n_2}{m}=\\sum_{k=0}^{m}\\binom{n_1}{k}\\binom{n_2}{m-k}$$ 这个证明非常显然，就不写了 $$\\sum_{k=0}^n\\binom{n}{k}^2=\\binom{2n}{n}$$ 这个恒等式的证明如下： $$\\sum_{k=0}^n\\binom{n}{k}^2=\\sum_{k=0}^n\\binom{n}{k}\\binom{n}{n-k}=\\binom{2n}{n}$$ 最后一步利用了前面那个等式","link":"/花里胡哨的二项式系数/"},{"title":"关于证明","text":"证明的方法用来证明形如$\\forall x(P(x)\\to Q(x))$的定理 直接证明法也就是条件语句$p\\to q$ 反证法条件语句$p\\to q$等价于它的逆否命题$\\neg q \\to \\neg p$ 空证明和平凡证明空证明如果知道$p$为假，那么就能证明条件语句$p \\to q$为真 平凡证明如果知道$q$为真，那么就能证明条件语句$p \\to q$为真 归谬证明法假如要证明命题$p$是真的。假定我们能找到一个矛盾式$q$使得$\\neg p \\to q$为真。那么这就意味着$p$为真 因为$r \\land \\neg r$一定是一个矛盾式，所以如果我们能够证明对某个命题$r$，$\\neg p \\to (r \\land \\neg r)$为真，就能证明$p$是真的。 举例证明$\\sqrt{2}$是无理数 证明设$p$是命题“$\\sqrt{2}$是无理数“。假定$\\neg p$为真，即“$\\sqrt{2}$为有理数，则存在整数$a$和$b$满足$\\sqrt{2}=\\frac{a}{b}$其中$b \\neq 0$并且$a$和$b$没有公因子 等式两端取平方，则 $$2=\\frac{a^2}{b^2}$$ 因此 $$2b^2=a^2$$ 可得$a^2$是偶数，通过反证法可得出$a$也是偶数，那么$\\exists c$有$a=2c$。那么 $$2b^2=4c^2$$ 等式两端除以$2$得 $$b^2=2c^2$$ 同理可得$b$是偶数。 我们证明了假设$\\neg p$导致等式$\\sqrt{2}=\\frac{a}{b}$并且$a$和$b$没有公因子，又推出$a$和$b$有公因子$2$，推出了矛盾，因此证明了$p$为真 等价证明法为了证明一个双条件命题的定理，即形如$p \\leftrightarrow q$的语句，那么只需证明$p \\to q$和$q \\to p$都是真的。 因为 $$(p \\leftrightarrow q) \\leftrightarrow(p \\to q) \\land (q \\to p)$$ 反例证明法如果要证明形如$\\forall x P(x)$的语句为假，只要能找到一个反例$x$使$P(x)$为假 穷举证明法和分情形证明法为了证明如下的条件语句 $$(p_1 \\lor p_2 \\lor \\cdots \\lor p_n) \\to q$$ 可以用永真式 $$[(p_1 \\lor p_2 \\lor \\cdots \\lor p_n) \\to q] \\leftrightarrow [(p_1 \\to q) \\land (p_2 \\to q) \\land \\cdots \\land (p_n \\to q)]$$ 这种论证称为分情形证明法 穷举证明法如果一些证明只需通过检验相对少量的例子来证明，那么这样的证明叫做穷举证明法，一个穷举证明法是分情形证明的特例 分情形证明法分情形证明一定要覆盖定理中出现的所有可能情况 存在性证明$\\exists xP(x)$这类命题的证明称为存在性证明。 有时可以通过找出一个使得$P(a)$为真的元素$a$来给出$\\exists xP(x)$的存在性证明。这样的存在性证明称为是构造性的，也可以给出一种非构造性的存在性证明，即不是找出使$P(a)$为真的元素$a$，而是以某种其他方式来证明$\\exists xP(x)$为真。给出非构造性证明的一种常用方法是使用归谬证明，证明该存在量化式的否定式蕴含一个矛盾。 一个非构造性的存在性证明证明存在无理数$x$和$y$使得$x^y$是有理数 证明由之前的例子可得$\\sqrt{2}$是无理数，考虑数$\\sqrt{2}^{\\sqrt{2}}$，如果它是有理数，那就存在两个无理数$x$和$y$是有理数，即$x=\\sqrt{2}, y=\\sqrt{2}$，另一方面如果$\\sqrt{2}^{\\sqrt{2}}$是无理数，那么令$x=\\sqrt{2}^{\\sqrt{2}},y=\\sqrt{2}$，因此$x^y=(\\sqrt{2}^{\\sqrt{2}})^{\\sqrt{2}}=\\sqrt{2}^{(\\sqrt{2}\\cdot \\sqrt{2})}=\\sqrt{2}^{2}=2$ 唯一性证明唯一性证明的两个部分如下 存在性：证明存在某个元素$x$具有期望的性质 唯一性：证明如果$y \\neq x$，则$y$不具有期望的性质 我们也可以等价地证明如果$x$和$y$都具有期望的性质，则$x=y$","link":"/证明/"},{"title":"边分治","text":"边分治用来解决一些点分治中一些解决不了的问题。 比如说点分治时有很多棵子树，合并这些信息时不能保证时间复杂度。 而边分治时最多只会有两棵子树，就可以很好地解决问题。 算法与点分治大致相同，就是找到一条边使得删去这条边后最大的那棵子树的大小最小。 但这个算法在菊花图时时间复杂度会退化成$O(n^2)$，因此需要将原树转换为一棵二叉树，这样每个点度数最多为$3$，分治后子树大小最多为原树的$\\frac{2}{3}$，就不会出现刚刚那样的问题了。 但边分治还有一个限制条件，那就是后来加进去的边对答案不会产生影响 我的多叉树转二叉树的代码，（显然最后的点数nn最多只有$2n$）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void dfs1(int u, int father){ for (int i = head[u]; i; i = nextx[i]) { int v = vet[i]; if (v != father) { dfs1(v, u); vec[u].push_back(v); } }}int main(){ dfs1(1, 0); int nn = n; edgenum = 1; memset(head, 0, sizeof(head)); for (int i = 1; i &lt;= n; i++) { if ((int)vec[i].size() &lt; 2) { for (int j = 0; j &lt; (int)vec[i].size(); j++) { add(i, vec[i][j], ); add(vec[i][j], i, ); } } else { int pre = i; for (int j = 0; j &lt; (int)vec[i].size() - 2; j++) { add(pre, vec[i][j], ); add(vec[i][j], pre, ); nn++; x[nn] = x[i]; add(pre, nn, ); add(nn, pre, ); pre = nn; } add(pre, vec[i][vec[i].size() - 2], ); add(vec[i][vec[i].size() - 2], pre, ); add(pre, vec[i][vec[i].size() - 1], ); add(vec[i][vec[i].size() - 1], pre, ); } }} 当然可以更简单粗暴一些，代价就是点数会稍微多一点点，但还是不会超过$2n$: 123456789101112131415161718192021int main(){ dfs1(1, 0); int nn = n; edgenum = 1; memset(head, 0, sizeof(head)); for (int u = 1; u &lt;= n; u++) { int pre = u; for (int i = 0; i &lt; (int)vec[u].size(); i++) { add(pre, vec[u][i], ); add(vec[u][i], pre, ); nn++; add(pre, nn, ); add(nn, pre, ); pre = nn; } }} 其他的部分和点分治差不多。 这里是找根的代码: 123456789101112131415161718void getroot(int u, int father, int S){ size[u] = 1; for (int i = head[u]; i; i = nextx[i]) { int v = vet[i]; if (v != father &amp;&amp; ! vis[i]) { getroot(v, u, S); f[i &gt;&gt; 1] = std::max(size[v], S - size[v]); if (f[i &gt;&gt; 1] &lt; f[root &gt;&gt; 1]) { root = i; } size[u] += size[v]; } }} 分治的大致框架: 1234567891011121314151617181920212223242526272829303132333435void dfs(int u, int father, int cas, ){ size[u] = 1; for (int i = head[u]; i; i = nextx[i]) { int v = vet[i]; if (v != father &amp;&amp; ! vis[i]) { dfs(v, u, cas, ); size[u] += size[v]; } } //}void solve(int rt, int father, int S){ if (! rt) { return; } vis[rt] = vis[rt ^ 1] = 1; for (int i = 0; i &lt; 2; i++) { dfs(vet[rt ^ i], 0, i, ); } //solve for (int i = 0; i &lt; 2; i++) { root = 0; int ss = size[vet[rt ^ i]]; getroot(vet[rt ^ i], 0, ss); solve(root, 0, ss); }}","link":"/边分治/"}],"tags":[{"name":"树","slug":"树","link":"/tags/树/"},{"name":"分治","slug":"分治","link":"/tags/分治/"},{"name":"CDQ分治","slug":"CDQ分治","link":"/tags/CDQ分治/"},{"name":"树分治","slug":"树分治","link":"/tags/树分治/"},{"name":"点分治","slug":"点分治","link":"/tags/点分治/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"黑科技","slug":"黑科技","link":"/tags/黑科技/"},{"name":"数学","slug":"数学","link":"/tags/数学/"},{"name":"FFT与NTT","slug":"FFT与NTT","link":"/tags/FFT与NTT/"},{"name":"微积分","slug":"微积分","link":"/tags/微积分/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"关于本站","slug":"关于本站","link":"/tags/关于本站/"},{"name":"反演","slug":"反演","link":"/tags/反演/"},{"name":"组合数学","slug":"组合数学","link":"/tags/组合数学/"},{"name":"自动机","slug":"自动机","link":"/tags/自动机/"},{"name":"后缀自动机","slug":"后缀自动机","link":"/tags/后缀自动机/"},{"name":"概率","slug":"概率","link":"/tags/概率/"},{"name":"线性基","slug":"线性基","link":"/tags/线性基/"},{"name":"二项式系数","slug":"二项式系数","link":"/tags/二项式系数/"},{"name":"边分治","slug":"边分治","link":"/tags/边分治/"}],"categories":[]}