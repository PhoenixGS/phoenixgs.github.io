{"meta":{"title":"PhoenixGS","subtitle":null,"description":null,"author":"PhoenixGS","url":"http://x.phoenixgs.cn"},"pages":[{"title":"About","date":"2018-04-10T07:35:55.597Z","updated":"2018-04-10T07:35:55.561Z","comments":true,"path":"about/index.html","permalink":"http://x.phoenixgs.cn/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-04-10T07:36:06.983Z","updated":"2018-04-10T07:36:06.949Z","comments":true,"path":"categories/index.html","permalink":"http://x.phoenixgs.cn/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-04-10T07:36:14.332Z","updated":"2018-04-10T07:36:14.299Z","comments":true,"path":"tags/index.html","permalink":"http://x.phoenixgs.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于证明","slug":"证明","date":"2018-10-23T15:30:35.000Z","updated":"2018-10-23T15:31:49.383Z","comments":true,"path":"2018/10/23/证明/","link":"","permalink":"http://x.phoenixgs.cn/2018/10/23/证明/","excerpt":"","text":"关于证明证明的方法用来证明形如$\\forall x(P(x)\\to Q(x))$的定理\u001b 直接证明法也就是条件语句$p\\to q$ 反证法\b条件语句$p\\to q$等价于它的逆否命题$\\neg q \\to \\neg p$ 空证明和平凡证明空证明如果知道$p$为假，那么就能证明条件语句$p \\to q$为真 平凡证明如果\u001b知道$q$为真，那么就能证明条件语句$p \\to q$为真 归谬证明法假如要证明命题$p$是真的。假定我们能找到一个矛盾式$q$使得$\\neg p \\to q$为真。那么这就意味着$p$为真 因为$r \\land \\neg r$一定是一个矛盾式，所以如果我们能够证明对某个命题$r$，$\\neg p \\to (r \\land \\neg r)$为真，就能证明$p$是真的。 \b举例证明$\\sqrt{2}$是无理数 证明设$p$是命题“$\\sqrt{2}$是无理数“。假定$\\neg p$为真，即“$\\sqrt{2}$为有理数，则存在整数$a$和$b$满足$\\sqrt{2}=\\frac{a}{b}$其中$b \\neq 0$并且$a$和$b$没有公因子 等式两端取平方，则 $$2=\\frac{a^2}{b^2}$$ 因此 $$2b^2=a^2$$ 可得$a^2$是偶数，通过反证法可得出$a$也是偶数，那么$\\exists c$有$a=2c$。那么 $$2b^2=4c^2$$ 等式两端除以$2$得 $$b^2=2c^2$$ 同理可得$b$是偶数。 我们证明了假设$\\neg p$导致等式$\\sqrt{2}=\\frac{a}{b}$并且$a$和$b$没有公因子，又推出$a$和$b$有公因子$2$，推出了矛盾，因此证明了$p$为真 等价证明法为了证明一个双条件命题的定理，即形如$p \\leftrightarrow q$的语句，那么只需证明$p \\to q$和$q \\to p$都是真的。 因为 $$(p \\leftrightarrow q) \\leftrightarrow(p \\to q) \\land (q \\to p)$$ 反例证明法如果要证明形如$\\forall x P(x)$的语句为假，只要能找到一个反例$x$使$P(x)$为假 穷举证明法和分情形证明法为了证明如下的条件语句 $$(p_1 \\lor p_2 \\lor \\cdots \\lor p_n) \\to q$$\b可以用永真式 $$[(p_1 \\lor p_2 \\lor \\cdots \\lor p_n) \\to q] \\leftrightarrow [(p_1 \\to q) \\land (p_2 \\to q) \\land \\cdots \\land (p_n \\to q)]$$ 这种论证称为分情形\b证明法 穷举证明法如果一些证明只需通过检验相对少量的例子来证明，那么这样的证明叫做穷举证明法，一个穷举证明法是分情形证明的特例 分情形证明法分情形证明一定要覆盖定理中出现的所有可能情况 存在性证明$\\exists xP(x)$这类命题的证明称为存在性证明。 有时可以通过找出一个使得$P(a)$为真的元素$a$来给出$\\exists xP(x)$的存在性证明。这样的存在性证明称为是构造性的，也可以给出一种非构造性的存在性证明，即不是找出使$P(a)$为真的元素$a$，而是以某种其他方式来证明$\\exists xP(x)$为真。给出非构造性证明的一种常用方法是使用归谬证明，证明该存在量化式的否定式蕴含一个矛盾。 一个非构造性的存在性证明证明存在无理数$x$和$y$使得$x^y$是有理数 证明由之前的例子可得$\\sqrt{2}$是无理数，考虑数$\\sqrt{2}^{\\sqrt{2}}$，如果它是有理数，那就存在两个无理数$x$和$y$是有理数，即$x=\\sqrt{2}, y=\\sqrt{2}$，另一方面如果$\\sqrt{2}^{\\sqrt{2}}$是无理数，那么令$x=\\sqrt{2}^{\\sqrt{2}},y=\\sqrt{2}$\b，因此$x^y=(\\sqrt{2}^{\\sqrt{2}})^{\\sqrt{2}}=\\sqrt{2}^{(\\sqrt{2}\\cdot \\sqrt{2})}=\\sqrt{2}^{2}=2$ 唯一性证明唯一性证明的两个部分如下 存在性：证明存在某个元素$x$具有期望的性质 唯一性：证明如果$y \\neq x$，则$y$不具有期望的性质\b 我们也可以等价地证明如果$x$和$y$都具有期望的性质，则$x=y$","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"}]},{"title":"反演","slug":"反演","date":"2018-10-16T15:08:32.000Z","updated":"2018-10-16T15:08:46.252Z","comments":true,"path":"2018/10/16/反演/","link":"","permalink":"http://x.phoenixgs.cn/2018/10/16/反演/","excerpt":"","text":"反演反演原理设 $$ g_n = \\sum_{i = 0} ^ n a_{ni}f_i $$ $$ \\sum_{i = 0}^n b_{ni}g_i = f_n $$ 因此，反演公式要成立，即 $$ \\sum_{k = j}^ib_{ik}a_{kj} = [i = j] = \\delta_{ij} $$ $$ \\sum_{k = j}^ia_{ik}b_{kj} = [i = j] = \\delta_{ij} $$ 二项式反演","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"}]},{"title":"Prufer","slug":"Prufer","date":"2018-10-16T15:05:16.000Z","updated":"2018-10-16T15:09:56.410Z","comments":true,"path":"2018/10/16/Prufer/","link":"","permalink":"http://x.phoenixgs.cn/2018/10/16/Prufer/","excerpt":"Prufer序Prufer序一个Prufer数列和一个带编号的无根树是一一对应的 树-&gt;Prufer序每次找这棵树中编号最小的叶子节点，将与这个点相连的点加入Prufer序，去掉这个点以及相连的边。重复这个操作直到剩下两个点。 Prufer序-&gt;树设点集$ V={1,2,…,n} $，每次在$V$中找出最小的未在Prufer序中出现过的数，然后在$V$中删除，与Prufer序中的第一个数相连，Prufer序中的第一个数删除。重复这个操作直到$|V|=2$（Prufer序为空），最后将$V$中的两个点相连。","text":"Prufer序Prufer序一个Prufer数列和一个带编号的无根树是一一对应的 树-&gt;Prufer序每次找这棵树中编号最小的叶子节点，将与这个点相连的点加入Prufer序，去掉这个点以及相连的边。重复这个操作直到剩下两个点。 Prufer序-&gt;树设点集$ V={1,2,…,n} $，每次在$V$中找出最小的未在Prufer序中出现过的数，然后在$V$中删除，与Prufer序中的第一个数相连，Prufer序中的第一个数删除。重复这个操作直到$|V|=2$（Prufer序为空），最后将$V$中的两个点相连。 证明这个感性理解一下感觉很有道理的 ​ 注意到，如果一个节点A不是叶子节点，那么它至少有两条边；但在上述过程结束后，整个图只剩下一条边，因此节点A的至少一个相邻节点被去掉过，节点A的编号将会在这棵树对应的Prüfer编码中出现。反过来，在Prüfer编码中出现过的数字显然不可能是这棵树（初始时）的叶子。于是我们看到，没有在Prüfer编码中出现过的数字恰好就是这棵树（初始时）的叶子节点。找出没有出现过的数字中最小的那一个（比如④），它就是与Prüfer编码中第一个数所标识的节点（比如③）相邻的叶子。接下来，我们递归地考虑后面n-3位编码（别忘了编码总长是n-2）：找出除④以外不在后n-3位编码中的最小的数（左图的例子中是⑦），将它连接到整个编码的第2个数所对应的节点上（例子中还是③）。再接下来，找出除④和⑦以外后n-4位编码中最小的不被包含的数，做同样的处理……依次把③⑧②⑤⑥与编码中第3、4、5、6、7位所表示的节点相连。最后，我们还有①和⑨没处理过，直接把它们俩连接起来就行了。由于没处理过的节点数总比剩下的编码长度大2，因此我们总能找到一个最小的没在剩余编码中出现的数，算法总能进行下去。这样，任何一个Prüfer编码都唯一地对应了一棵无根树，有多少个n-2位的Prüfer编码就有多少个带标号的无根树。 ——摘自Matrix67 性质 一棵n个节点的无根树唯一地对应了一个长度为n-2的数列，数列中的每个数都在1到n的范围内。 Prufer序列中某个编号出现的次数就等于这个编号的节点在无根树中的度数-1。 设无根树每个点的度数为$D_i$，则$\\sum_{i=1}^n(D_i-1)=n-2$（这好像是废话，，，因为$\\sum_{i=1}^nD_i=2(n-1)$。。。 Cayley公式Cayley公式一个完全图$K_n$有$n^{n-2}$棵生成树 证明由Prufer可知，一个Prufer数列和一个带编号的无根树是一一对应的，那么这个公式也很显然了。因为$n$个节点的无根树的Prufer序长度为$n-2$，序列中每个值取值为${1,2,3,…,n}$，因此不同的Prufer序有$n^{n-2}$个，因此生成树也有这么多个。 推广n个节点的度依次为$D_1,D_2,…,D_n$的无根树共有$\\frac{(n-2)!}{(D_1-1)!(D_2-1)!\\cdots(D_n-1)!}$个。 例题BZOJ1005 LOJ6395 https://www.cnblogs.com/onioncyc/p/9052946.html 参考资料http://www.matrix67.com/blog/archives/682 https://www.cnblogs.com/dirge/p/5503289.html","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://x.phoenixgs.cn/tags/算法/"},{"name":"树","slug":"树","permalink":"http://x.phoenixgs.cn/tags/树/"}]},{"title":"容斥原理","slug":"容斥原理","date":"2018-06-11T14:14:15.000Z","updated":"2018-10-16T15:12:06.358Z","comments":true,"path":"2018/06/11/容斥原理/","link":"","permalink":"http://x.phoenixgs.cn/2018/06/11/容斥原理/","excerpt":"容斥原理表达式容斥原理$$ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1}|A_i|- \\sum_{1 \\leq i &lt; j \\leq n}|A_i \\cap A_j|+\\\\ \\sum_{1 \\leq i &lt; j &lt; k \\leq n}|A_i \\cap A_j \\cap A_k| - \\cdots +(-1)^{n-1}|A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$$$ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1} |A_i| - \\sum_{1 \\leq i &lt; j \\leq n} |A_i \\cap A_j|+ \\sum_{1 \\leq i &lt; j &lt; k \\leq n} |A_i \\cap A_j \\cap A_k| - \\cdots + (-1)^{n-1} |A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$","text":"容斥原理表达式容斥原理$$ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1}|A_i|- \\sum_{1 \\leq i &lt; j \\leq n}|A_i \\cap A_j|+\\\\ \\sum_{1 \\leq i &lt; j &lt; k \\leq n}|A_i \\cap A_j \\cap A_k| - \\cdots +(-1)^{n-1}|A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$$$ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1} |A_i| - \\sum_{1 \\leq i &lt; j \\leq n} |A_i \\cap A_j|+ \\sum_{1 \\leq i &lt; j &lt; k \\leq n} |A_i \\cap A_j \\cap A_k| - \\cdots + (-1)^{n-1} |A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$ 逐步淘汰原理（筛法公式）$$ | \\complement_S A_1 \\cap \\complement_S A_2 \\cap \\cdots \\cap \\complement_S A_n| = |S|-\\sum^n_{i=1}|A_i|+ \\sum_{1 \\leq i &lt; j \\leq n}|A_i \\cap A_j|-\\\\ \\sum_{1 \\leq i &lt; j &lt; k \\leq n}|A_i \\cap A_j \\cap A_k| + \\cdots +(-1)^n|A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$ 容斥原理与求和及差分以二维求和为例$$ \\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}=\\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[i\\neq n \\lor j\\neq m]+x_{n,m} \\\\ = \\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[i\\neq n]+\\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[j\\neq m] -\\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[i\\neq n \\land j\\neq m]+x_{i,j} $$","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"}]},{"title":"dsu on tree","slug":"dsu-on-tree","date":"2018-05-20T11:24:02.000Z","updated":"2018-05-20T11:24:02.452Z","comments":true,"path":"2018/05/20/dsu-on-tree/","link":"","permalink":"http://x.phoenixgs.cn/2018/05/20/dsu-on-tree/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"Hello-World","date":"2016-05-29T03:07:22.000Z","updated":"2018-04-09T16:28:03.783Z","comments":true,"path":"2016/05/29/Hello-World/","link":"","permalink":"http://x.phoenixgs.cn/2016/05/29/Hello-World/","excerpt":"","text":"123456789#include &lt;cstdio&gt;int main()&#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", x + y); return 0;&#125;","categories":[],"tags":[]}]}