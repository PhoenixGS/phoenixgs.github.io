{"meta":{"title":"PhoenixGS","subtitle":null,"description":null,"author":"PhoenixGS","url":"http://x.phoenixgs.cn"},"pages":[{"title":"Categories","date":"2018-04-10T07:36:06.983Z","updated":"2018-04-10T07:36:06.949Z","comments":true,"path":"categories/index.html","permalink":"http://x.phoenixgs.cn/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-12-27T07:52:33.748Z","updated":"2018-12-27T07:52:33.748Z","comments":true,"path":"about/index.html","permalink":"http://x.phoenixgs.cn/about/index.html","excerpt":"","text":"我是一个\b智障 博客经常会进行增添和修改，但我也不知道该怎么搞更新日期。。。 所以看过的文章也可以再看一遍（大雾 如果发现我的博客中出现了错误，请务必联系我 QQ:1637281495 Telegram:@PhoenixGS Mail:thestarrydream@gmail.com"},{"title":"Tags","date":"2018-04-10T07:36:14.332Z","updated":"2018-04-10T07:36:14.299Z","comments":true,"path":"tags/index.html","permalink":"http://x.phoenixgs.cn/tags/index.html","excerpt":"","text":""},{"title":"TodoList","date":"2018-12-28T16:28:09.052Z","updated":"2018-12-28T05:29:42.911Z","comments":true,"path":"todolist/index.html","permalink":"http://x.phoenixgs.cn/todolist/index.html","excerpt":"","text":"Things:Done Things:Doing Things:Skip Content State Killed Date 二项式系数 Doing 容斥及反演 Doing 二进制分组 动态规划优化 树形DP 动态DP 最小表示 回文自动机 Minmax 反演 弦图 DP 字符串的最小表示 斯特林数 网络流24题 Min_25筛 Done 2018.11.30 后缀自动机 Done 2018.12.27 FFT &amp; NTT Done 2018.12.27"}],"posts":[{"title":"一个关于整值函数的结论","slug":"一个关于整值函数的结论","date":"2018-12-28T16:28:50.000Z","updated":"2018-12-29T00:15:33.752Z","comments":true,"path":"一个关于整值函数的结论/","link":"","permalink":"http://x.phoenixgs.cn/一个关于整值函数的结论/","excerpt":"结论 设\\(f(x)\\)是任意一个具有如下性质且在一个实数区间连续的单调递增函数且 \\[f(x)=整数\\to x=整数 \\] 只要\\(f(x),f(\\lfloor x \\rfloor), f(\\lceil x \\rceil)\\)有定义，那么就有 \\[f(\\lfloor x \\rfloor)=\\lfloor f(\\lfloor x \\rfloor) \\rfloor 和 f(\\lceil x \\rceil)=\\lceil f(\\lceil x \\rceil) \\rceil\\]","text":"结论 设\\(f(x)\\)是任意一个具有如下性质且在一个实数区间连续的单调递增函数且 \\[f(x)=整数\\to x=整数 \\] 只要\\(f(x),f(\\lfloor x \\rfloor), f(\\lceil x \\rceil)\\)有定义，那么就有 \\[f(\\lfloor x \\rfloor)=\\lfloor f(\\lfloor x \\rfloor) \\rfloor 和 f(\\lceil x \\rceil)=\\lceil f(\\lceil x \\rceil) \\rceil\\] 证明 此处证明底函数的情况，顶函数类似 若\\(x\\)为整数，那么结论显然成立 否则，\\(x\\)不为整数，那么就有\\(\\lfloor x \\rfloor&lt;x&lt;\\lceil x\\rceil\\)，那么\\(f(\\lfloor x\\rfloor)&lt;f(x)\\) 也就是说\\(\\lfloor f(\\lfloor x \\rfloor)\\rfloor \\leq \\lfloor f(x)\\rfloor\\) 若\\(\\lfloor f(\\lfloor x \\rfloor)\\rfloor &lt; \\lfloor f(x)\\rfloor\\)，那么\\(f(\\lfloor x\\rfloor)&lt;\\lfloor f(x)\\rfloor\\leq f(x)\\) 那么就存在一个\\(y\\)使得\\(\\lfloor x\\rfloor&lt;y\\leq x\\)且\\(f(y)=\\lfloor f(x)\\rfloor\\) 由函数的性质可知\\(y\\)是一个整数。又因为\\(x\\)不是整数，因此\\(x&lt; \\lceil x\\rceil\\)，所以\\(\\lfloor x\\rfloor &lt; y &lt; \\lceil x\\rceil\\)，但是不存在这样的整数。因此\\(\\lfloor f(x)\\rfloor = \\lfloor f(\\lfloor x \\rfloor)\\rfloor\\) 推论\\(\\alpha\\) 如果\\(m\\)是整数且\\(n\\)是正整数，那么 \\[\\lfloor \\frac{x+m}{n}\\rfloor=\\lfloor\\frac{\\lfloor x\\rfloor+m}{n}\\rfloor和\\lceil \\frac{x+m}{n}\\rceil=\\lceil\\frac{\\lceil x\\rceil+m}{n}\\rceil\\] 利用上面的结论证明显然 推论\\(\\beta\\) 如果\\(y,z\\)是正整数，那么 \\[\\lfloor\\frac{\\frac{x}{y}}{z}\\rfloor=\\lfloor\\frac{\\lfloor\\frac{x}{y}\\rfloor}{z}\\rfloor和\\lceil\\frac{\\frac{x}{y}}{z}\\rceil=\\lceil\\frac{\\lceil\\frac{x}{y}\\rceil}{z}\\rceil\\] 利用推论\\(\\alpha\\)证明显然 参考资料 《具体数学（中文第二版）》3.2节","categories":[],"tags":[]},{"title":"多项式求逆","slug":"多项式求逆","date":"2018-12-27T13:07:54.000Z","updated":"2018-12-27T13:09:47.743Z","comments":true,"path":"多项式求逆/","link":"","permalink":"http://x.phoenixgs.cn/多项式求逆/","excerpt":"定义 我们说\\(B(x)\\)是\\(A(x)\\)在模\\(x^n\\)意义下的逆元则是满足 \\[A(x)*B(x)\\equiv1(mod \\; x^n)\\] 分治 考虑分治 假如我们已经知道在模\\(x^{\\lceil \\frac{n}{2} \\rceil}\\)下\\(A\\)的逆\\(B&#39;\\)","text":"定义 我们说\\(B(x)\\)是\\(A(x)\\)在模\\(x^n\\)意义下的逆元则是满足 \\[A(x)*B(x)\\equiv1(mod \\; x^n)\\] 分治 考虑分治 假如我们已经知道在模\\(x^{\\lceil \\frac{n}{2} \\rceil}\\)下\\(A\\)的逆\\(B&#39;\\) 即 \\[A(x)*B&#39;(x)\\equiv 1(mod \\; x^{\\lceil \\frac{n}{2} \\rceil})\\] \\[A(x)*B&#39;(x)-1\\equiv 0(mod \\; x^{\\lceil \\frac{n}{2} \\rceil})\\] 两边平方即可得 \\[(A(x)*B&#39;(x)-1)^2\\equiv 0(mod \\; x^{2\\lceil \\frac{n}{2} \\rceil})\\] \b显然\\(2\\lceil \\frac{n}{2} \\rceil \\geq n\\) 所以 \\[(A(x)*B&#39;(x)-1)^2\\equiv 0(mod \\; x^n)\\] \\[A^2(x)*B&#39;^2(x)-2A(x)*B&#39;(x)+1\\equiv 0(mod \\; x^n)\\] \\[2A(x)*B&#39;(x)-A^2(x)*B&#39;^2(x)\\equiv 1(mod \\; x^n)\\] \\[A(x)(2B&#39;(x)-A(x)*B&#39;^2(x))\\equiv 1(mod \\; x^n)\\] 那么\\(B(x)=2B&#39;(x)-A(x)*B&#39;^2(x)\\)即为满足\\(A(x)*B(x)\\equiv 1(mod \\; x^n)\\)的\\(B(x)\\) 参考资料 http://nirobc.com/20181212.pdf https://www.cnblogs.com/yoyoball/p/8724115.html","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"},{"name":"FFT与NTT","slug":"FFT与NTT","permalink":"http://x.phoenixgs.cn/tags/FFT与NTT/"},{"name":"算法","slug":"算法","permalink":"http://x.phoenixgs.cn/tags/算法/"}]},{"title":"FFT与NTT","slug":"FFT与NTT","date":"2018-12-27T13:05:58.000Z","updated":"2018-12-27T13:09:51.483Z","comments":true,"path":"FFT与NTT/","link":"","permalink":"http://x.phoenixgs.cn/FFT与NTT/","excerpt":"快速傅立叶变换 FFT 对于两个多项式 \\[A(x)=\\sum_{i=0}^{N-1}a_ix^i\\] \\[B(x)=\\sum_{i=0}^{N-1}b_ix^i\\] FFT可以在\\(O(nlgn)\\)的时间内求出 \\[C(x)=A(x)*B(x)=\\sum_{i=0}^{2(N-1)}c_ix^i\\] 其中\\(c_i=\\sum_{j=0}^ia_jb_{i-j}\\)","text":"快速傅立叶变换 FFT 对于两个多项式 \\[A(x)=\\sum_{i=0}^{N-1}a_ix^i\\] \\[B(x)=\\sum_{i=0}^{N-1}b_ix^i\\] FFT可以在\\(O(nlgn)\\)的时间内求出 \\[C(x)=A(x)*B(x)=\\sum_{i=0}^{2(N-1)}c_ix^i\\] 其中\\(c_i=\\sum_{j=0}^ia_jb_{i-j}\\) 前置知识 在复数域下，方程\\(x^n=1\\)有\\(n\\)个解\\(\\omega_N^i,(i=1\\dots N)\\) 其中 \\[\\omega_N^i=(\\cos\\frac{2\\pi i}{N}, \\sin\\frac{2\\pi i}{N})\\] 可以看作是平面直角坐标系中单位圆上间距相等的\\(N\\)个点 然后可以自己去学习一下复数一下qwq 假如把复数用极坐标表示 \\(z=r(\\cos \\varphi+i\\sin \\varphi)\\) 那么复数的乘法就是模长(\\(r\\))相乘，幅角(\\(\\varphi\\))相加 单位根有如下性质： \\[\\omega_N^i\\omega_N^j=\\omega_N^{i+j}\\] \\[\\omega_N^i=\\omega_N^{N+i}\\] \\[\\omega_N^{\\frac{N}{2}}=-1\\] \\[\\omega_N^i=\\omega_{cN}^{ci}\\] DFT 我们尝试将\\(N\\)下的单位根代入多项式得到\\(N\\)个值 也就是 \\[F:\\{a_0,a_1,\\dots a_{N-1}\\} \\to \\{A(\\omega_0),A(\\omega_1),\\dots A(\\omega_{N-1})\\}\\] 显然，可以在\\(A,B\\)中补\\(0\\)使得\\(N=2^k(k\\in \\mathbb{N})\\) 考虑分治 对于\\(0\\leq i &lt; \\frac{N}{2}\\) 有 \\[ \\begin{aligned} A_i&amp;=\\sum_{j=0}^{N-1}a_j\\omega_N^{ij} \\\\ A_{i+\\frac{N}{2}}&amp;=\\sum_{j=0}^{N-1}a_j\\omega_N^{(i+\\frac{N}{2})j}=\\sum_{j=0}^{N-1}(-1)^ja_j\\omega_N^{ij} \\end{aligned} \\] 将\\(\\sum\\)中的奇偶项分开来 \\[ \\begin{aligned} A_i&amp;=\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j}\\omega_{\\frac{N}{2}}^{ij}+\\omega_N^i\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j+1}\\omega_{\\frac{N}{2}}^{ij} \\\\ A_{i+\\frac{N}{2}}&amp;=\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j}\\omega_{\\frac{N}{2}}^{ij}-\\omega_N^i\\sum_{j=0}^{\\frac{N}{2}-1}a_{2j+1}\\omega_{\\frac{N}{2}}^{ij} \\end{aligned} \\] 非常奇妙是不是？这样就可以分治下去啦 IDFT 与DFT类似 只不过将DFT中的每个\\(\\omega\\)都变成\\(\\omega^{-1}\\)，然后最后每个\\(A_i\\)都除以\\(N\\) 代入进去显然可以发现是对的。 如果要严格说明是唯一的话就要用线性代数中的Vandermonde矩阵了。。 这里就不写了，感兴趣的可以去了解一下，《算法导论》里讲的也挺详细的 例题 来自衲姐NiroBC的例题（Orz） 给一个\\(N\\)位的\\(B\\)进制数\\(A\\)，将它转为十进制。(\\(N,B\\leq 10^5\\)) 考虑分治 对于\\(N\\)位的\\(B\\)进制数， 设\\(M=2^k\\leq \\frac{N}{2}\\) 假如我们已经求出了\\(\\sum_{i=0}^{M-1}A_iB^i\\)的十进制数以及\\(\\sum_{i=0}^{N-M-1}A_{i+M}B^i\\)的十进制数 那么就可以用FFT将\\(\\sum_{i=0}^{N-M-1}A_{i+M}B^i\\)乘上\\(B^M\\) 其中\\(B^M\\)的十进制数也可以用FFT预处理 时间复杂度为\\(O(nlg^2n)\\) 快速数论变换 NTT NTT与FFT大体上十分相似 主要是因为FFT涉及许多实数运算，因此很容易丢精 当需要对所求的多项式对\\(M\\)取模时，NTT就是一个非常好的选择 欧拉定理： 若\\(n,a\\)为正整数，且\\(n,a\\)互素（即\\(\\gcd(a,n)=1\\)），则 \\[a^{\\varphi(n)}\\equiv 1 \\quad (mod\\; n)\\] NTT一般用于\\(M\\)是质数的情况，因此在这里费马小定理： 费马小定理： 假如\\(a\\)是一个整数，\\(p\\)是一个质数 \\[a^{p-1}\\equiv 1 \\quad (mod\\; p)\\] 原根\\(G\\)，满足集合\\(\\{G^0, G^1, G^2, \\cdots, G^{\\varphi(M) - 1}\\}\\)中含有了所有与\\(M\\)互质的数。 若\\(M\\)可以表示成\\(2^k*t+1\\)， 其中\\(t\\)是奇数 那么对于小于\\(2^k\\)的\\(N\\)，\\(G^{\\frac{M-1}{N}}\\)都可以作为单位元\\(w\\)，其他就和FFT没什么区别了 参考资料 http://nirobc.com/20181205.pdf http://nirobc.com/20181212.pdf http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"},{"name":"FFT与NTT","slug":"FFT与NTT","permalink":"http://x.phoenixgs.cn/tags/FFT与NTT/"},{"name":"算法","slug":"算法","permalink":"http://x.phoenixgs.cn/tags/算法/"}]},{"title":"后缀自动机","slug":"后缀自动机","date":"2018-12-27T07:43:09.000Z","updated":"2018-12-28T07:16:26.570Z","comments":true,"path":"后缀自动机/","link":"","permalink":"http://x.phoenixgs.cn/后缀自动机/","excerpt":"SAM 关于后缀自动机整个算法，在这了就不多说了，感觉别人写的都很好QAQ 可以去看看参考资料里的几篇文章，感觉学过OI的应该都能看懂。。 在这里我就写一下自己的理解和一些性质和应用","text":"SAM 关于后缀自动机整个算法，在这了就不多说了，感觉别人写的都很好QAQ 可以去看看参考资料里的几篇文章，感觉学过OI的应该都能看懂。。 在这里我就写一下自己的理解和一些性质和应用 我的模版 1234567891011121314151617181920212223242526272829303132333435363738394041424344void extend(int c)&#123; knum++; int u = last; int v = knum; last = knum; len[v] = len[u] + 1; for (; u &amp;&amp; ! to[u][c]; u = pre[u]) &#123; to[u][c] = v; &#125; if (! u) &#123; pre[v] = root; return; &#125; int w = to[u][c]; if (len[u] + 1 == len[w]) &#123; pre[v] = w; return; &#125; knum++; int neww = knum; pre[neww] = pre[w]; len[neww] = len[u] + 1; for (int i = 0; i &lt; 26; i++) &#123; to[neww][i] = to[w][i]; &#125; pre[w] = pre[v] = neww; for (; u &amp;&amp; to[u][c] == w; u = pre[u]) &#123; to[u][kkc] = neww; &#125;&#125;int main()&#123; //init last = 1; knum = 1; root = 1;&#125; 时间复杂度 状态数 状态数是\\(O(n)\\)的，这十分显然。 每个状态按照pre边连接可以变成一棵树。 父子节点集合关系是包含的 兄弟节点集合关系是无交的 所以脑补一下，就可以发现状态个数最多就是二叉树的时候，也就只有\\(2n-1\\)。。。 转移数 首先，一个十分显然的结论是，转移数最多为\\(O(\\Sigma * n)\\)，其中\\(\\Sigma\\)表示字符集大小 有一个更加紧的上限： \\[3n-4\\; (对于n\\geq 3)\\] 然后，考虑以下的事实： 初始节点开始的最长的转移路径树 节点数为\\(2n-1\\)，那么边数即为\\(2n-2\\) 考虑不在这棵树中的转移\\(u\\to v\\)，字符为\\(y\\) 那么初始节点到\\(u\\)的字典序最大字符串（最小应该也行，只要保证唯一）\\(x\\)，以及\\(v\\)到任意一个终止节点的最长字符串（同样也可以是最小）\\(z\\)。 \\(x+y+z\\)即为原串的一个后缀，后缀只有\\(n-1\\)个，（原串这个后缀肯定在刚开始的树上）。 因此转移数的上限即为\\(3n-4\\) 能达到上限的字符串 \\[abb \\dots bc\\] 修改to的次数 从上面的模版可以看出，现在除了 1234for (; u &amp;&amp; to[u][c] == w; u = pre[u])&#123; to[u][kkc] = neww;&#125; 这一段之外时间复杂度就是\\(O(n)\\) 那么，这一段的总共的时间复杂度是多少呢？ 定义\\(minlen(u)\\)表示为能走到\\(u\\)的所有字符串的最小长度 显然\\(minlen\\)有一个性质： \\[minlen(u)&gt;minlen(pre[u])&gt;minlen(pre[pre[u]])\\cdots &gt; minlen(root) \\quad (*)\\] 那么考虑\\(minlen(pre[last])\\)这个东西 如果执行到了这个for循环，那么\\(pre[last]\\)就变成了\\(neww\\) 可以发现这个for循环如果循环了\\(k\\)次 那么\\(minlen(neww)\\leq minlen(lastu)+1\\)，其中\\(lastu\\)是for循环枚举的最后的\\(u\\) 通过\\((*)\\)可以知道\\(minlen(lastu)\\leq minlen(pre[last])-k\\) 那么\\(minlen(pre[neww])\\leq minlen(pre[last])-k+1\\) 其中\\(+1\\)最多加\\(n\\)次，\\(minlen(pre[last])\\)的初值为\\(0\\) 从而for循环执行的次数是\\(O(n)\\)的 总结 从上面三部分可知，构建后缀自动机的的时间复杂度为\\(O(n)\\) 如果有不懂的欢迎打扰 如果有哪位大佬能想出更好的证明方法的话，请务必告诉我QAQ 一些性质及应用 后缀自动机每个节点的状态为：后面还要输入哪些串就是一个后缀 对于后缀自动机中每个节点所表示的字符串（起点到这个节点的所有字符串），是在原串中出现位置一模一样的所有字符串。按照长度排序后，是长度依次减一并且是前一个的后缀。比如：\\(abcac, bcac, cac\\) 一个节点沿着pre一直走到起始节点的所有节点所表示的所有字符串，正好是最长的字符串的所有后缀 本质不同的字串个数 答案显然是\\(\\sum_u len[u] - len[pre[u]]\\) 字符串循环移位的最小表示 求\\(S\\)的循环移位的最小表示 将\\(S+S\\)建一个后缀自动机 然后从起始节点开始贪心每次选最小的出边，选择\\(|S|\\)次后得到的字符串就是最小表示 求\\(right\\)集合 可以在每次extend之后令size[last] = 1，然后按照pre边可以求出每个状态\\(right\\)集合的大小 如果只是想单纯地输出每个状态的集合的话，可以直接沿着pre边的反向边求出\\(right\\)集合。因为前面也已经说过，走到的状态数最多只有\\(2|right|-1\\)个 当然也可以利用线段树合并搞出每个状态具体的\\(right\\)集合，这样就会多一个\\(log\\) 用拓扑排序的写法写起来比较简单，也可以用DFS 求两个串的最长公共子串 求\\(S\\)和\\(T\\)的最长公共子串 可以先对\\(S\\)建一个后缀自动机 然后拿\\(T\\)在自动机上跑，如果有转移则转，没有转移就沿着pre向上跳（话说这不是自动机的基本操作吗。。。） 每次转移后拿len更新答案 推广：广义后缀自动机 说是广义，其实就是建多个串\\(S_i\\)的后缀自动机。。。 那么应该怎么建呢？ 一种十分简单粗暴的方法就是将\\(S_1+&#39;\\#&#39;+S_2+&#39;\\#&#39;+\\cdots +&#39;\\#&#39;+S_k\\)建后缀自动机 还有一种方法，就是将原来的模版改成这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void extend(int c)&#123; int u = last; if (to[u][c]) &#123; int w = to[u][c]; if (len[u] + 1 == len[w]) &#123; return w; &#125; knum++; int neww = knum; pre[neww] = pre[w]; for (int i = 0; i &lt; s; i++) &#123; to[neww][i] = to[w][i]; &#125; len[neww] = len[u] + 1; pre[w] = neww; for (; u &amp;&amp; to[u][c] == w; u = pre[u]) &#123; to[u][c] = neww; &#125; return neww; &#125; knum++; int v = knum; last = knum; len[v] = len[u] + 1; for (; u &amp;&amp; ! to[u][c]; u = pre[u]) &#123; to[u][c] = v; &#125; if (! u) &#123; pre[v] = root; return; &#125; int w = to[u][c]; if (len[u] + 1 == len[w]) &#123; pre[v] = w; return; &#125; knum++; int neww = knum; pre[neww] = pre[w]; len[neww] = len[u] + 1; for (int i = 0; i &lt; 26; i++) &#123; to[neww][i] = to[w][i]; &#125; pre[w] = pre[v] = neww; for (; u &amp;&amp; to[u][c] == w; u = pre[u]) &#123; to[u][kkc] = neww; &#125;&#125;int main()&#123; //init last = 1; knum = 1; root = 1; for (int i ; ;) &#123; //add Si last = root; &#125;&#125; 每次添加完一个字符串后将last赋为root就行了 参考资料 http://nirobc.com/20181224.pdf https://oi-wiki.org/string/sam/ https://blog.csdn.net/qq_35649707/article/details/66473069","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://x.phoenixgs.cn/tags/算法/"},{"name":"自动机","slug":"自动机","permalink":"http://x.phoenixgs.cn/tags/自动机/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"http://x.phoenixgs.cn/tags/后缀自动机/"}]},{"title":"Min_25筛","slug":"Min-25","date":"2018-11-30T06:47:35.000Z","updated":"2018-12-27T08:28:04.773Z","comments":true,"path":"Min-25/","link":"","permalink":"http://x.phoenixgs.cn/Min-25/","excerpt":"简介 Min_25筛用来求一个函数的前缀和 如果函数是积性函数就可以做，如果不是积性函数的话有一部分也是可以做的 算法过程就像是在模拟埃氏筛法 时间复杂度是\\(O(\\frac{n^{\\frac{3}{4}}}{log(\\sqrt{n})})\\)，然而我并不会证","text":"简介 Min_25筛用来求一个函数的前缀和 如果函数是积性函数就可以做，如果不是积性函数的话有一部分也是可以做的 算法过程就像是在模拟埃氏筛法 时间复杂度是\\(O(\\frac{n^{\\frac{3}{4}}}{log(\\sqrt{n})})\\)，然而我并不会证 算法 质数的函数值的前缀和 设\\(m(x)\\)表示\\(x\\)的最小质因子 假如要求 \\[\\sum_{i = 1}^{n}f(i)[i是质数]\\] 首先将\\(\\sqrt{n}\\)之内的质数全部筛出来，放在prime数组里 设 \\[g(n,j)=\\sum_{i = 2}^{n}f(i)[m(i) &gt; prime_j 或 i 是质数]\\] 那么 \\[ g(n,j) = \\begin{cases} g(n,j - 1) - f(j)[g(\\lfloor \\frac{n}{prime_j} \\rfloor, j - 1) - g(prime_{j - 1}, j - 1)] &amp; prime_j^2 \\leq n \\\\\\\\ g(n,j - 1) &amp; prime_j^2 &gt; n \\end{cases} \\] 显然，其中的\\(g(prime_{j-1},j-1)=\\sum_{i=1}^{j-1}f(prime_i)\\) 那么原式中第一维有用的值只有\\(O(\\sqrt{n})\\)种，预处理即可 最终\\(g(n,primenum)\\)就是我们要求的\\(\\sum_{i = 1}^{n}f(i)[i是质数]\\) 关于\\(f(x)\\) 如果只求质数的函数值的话， \\(f(x)\\)应该满足下面几个条件： 若\\(x\\)是质数\\(f(x)\\)应该要能在\\(O(1)\\)内求出来 要能够快速求出\\(\\sum_{i=2}^{n}f&#39;(i)\\)，其中\\(f&#39;(i)=\\Pi_{j,k}f(j)[k &gt; 0][j^k|n]\\) 函数值的前缀和 递归版 假设我们要求的函数是\\(f(x)\\)，那么问题就是求 \\[\\sum_{i = 1}^{n}f(i)\\] 之前已经求出了 \\[\\sum_{i = 1}^{n}f(i)[i是质数]\\] 的值 那么，现在设 \\[h(n,j) = \\sum_{i=2}^nf(i)[m(i) \\geq prime_j]\\] 那么 \\[ h(n,j)=g(n,primenum) - g(prime_{i-1},i-1)+ \\\\\\\\ \\sum_{i=j}^{primenum}\\sum_{e\\geq 1 且 prime_i^{e+1}\\leq n}f(prime_i^e)h(\\lfloor \\frac{n}{prime_i^e} \\rfloor,i+1)+f(prime_i^{e+1}) \\] 和上面一样，第一维有用的取值只有\\(O(\\sqrt{n})\\)种 写一个递归函数，最后的答案即为\\(h(n,1)+f(1)\\) 假如就询问没几个\\(n\\)的答案，就可以用这种方法 非递归版 这次改变一下状态 设 \\[h(n,j)=\\sum_{i=2}^nf(i)[m(i)\\geq prime_j 或 i是质数]\\] 那么 \\[ h(n,j)=\\begin{cases} h(n,j+1)+\\\\\\\\ \\sum_{e \\geq 1 且prime_j^{e+1}\\leq n}f(prime_j^e)[h(\\lfloor \\frac{n}{prime_j^e} \\rfloor,j + 1) - g(prime_i,i)] &amp; prime_j^2 \\leq n \\\\\\\\ h(n,j+1) &amp; prime_j^2 &gt; n \\end{cases} \\] 有没有发现这个式子与质数函数值的前缀和的式子特别像？只不过质数一个是从小枚举到大，一个是从大枚举到小 答案为\\(h(n,1)+f(1)\\) 假如要询问许多\\(n&#39;= \\lfloor \\frac{n}{x} \\rfloor\\)的答案，就可以用这种方法 关于\\(f(x)\\) \\(f(x)\\)函数如果是积性函数，那么应该都可以做 假如不是的话，首先要满足求质数的函数值的前缀和的那些条件 并且若\\(x=ab,gcd(a,b)=1\\)，\\(f(x)\\)能\\(O(1)\\)从\\(f(a)\\)和\\(f(b)\\)合并，那么应该就能做了（其实我也不是很清楚qaq 关于时间复杂度 暂时还不会。。。 参考资料 http://www.cnblogs.com/zzqsblog/p/8302815.html http://www.hekai.site/wordpress/2018/09/04/min_25%E7%AD%9B/ https://blog.csdn.net/XianHaoMing/article/details/80397777 https://www.cnblogs.com/Menhera/p/9226649.html https://blog.csdn.net/ZLTJohn/article/details/79703503","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"},{"name":"算法","slug":"算法","permalink":"http://x.phoenixgs.cn/tags/算法/"},{"name":"数论","slug":"数论","permalink":"http://x.phoenixgs.cn/tags/数论/"}]},{"title":"概率论","slug":"概率论","date":"2018-10-27T14:38:38.000Z","updated":"2018-11-30T07:59:24.822Z","comments":true,"path":"概率论/","link":"","permalink":"http://x.phoenixgs.cn/概率论/","excerpt":"概念 样本空间：一个随机试验的所有可能结果组成的集合，标记为\\(S\\) 事件：\\(S\\)的一个子集\\(A\\)，\\(A\\subseteq \\Omega\\)，称为事件","text":"概念 样本空间：一个随机试验的所有可能结果组成的集合，标记为\\(S\\) 事件：\\(S\\)的一个子集\\(A\\)，\\(A\\subseteq \\Omega\\)，称为事件 概率公理 \\(0\\leq P(A)\\leq 1\\) \\(P(\\Omega)=1\\) 如果\\(A_1A_2A_3\\cdots\\)是一系列两两无关的事件，即对于任何\\(i,j,i\\neq j,A_i\\cap A_j=\\phi\\)，则 \\[P\\lgroup \\bigcup_{k=1}^{\\infty} A_k \\rgroup=\\sum_{k=1}^{\\infty}P(A_k)\\] 条件概率 令\\(B\\)为一个事件满足\\(P(B)&gt;0\\)，对于任意事件\\(A\\)，定义\\(A\\)的关于\\(B\\)的条件概率。 \\[P(A|B)=\\frac{P(A\\cap B)}{P(B)}\\] 独立 如果\\(A,B\\)满足\\(P(A\\cap B)=P(A)P(B)\\)，称\\(A,B\\)独立。 并且可以推出\\(P(A)=P(A|B)\\) 性质 概率的加法公式 \\[P(A\\cup B)=P(A)+P(B)-P(A\\cap B)\\] 并的界 \\[P(A\\cup B)\\leq P(A)+P(B)\\] 全概率公式 设\\(B_1B_2B_3\\cdots B_n\\)是样本空间\\(S\\)中互不相交的一系列事件，并且满足\\(S=\\bigcup_{k=1}^n B_k\\)，那么对于任意事件\\(A\\) \\[P(A)=\\sum_{k=1}^nP(A|B_k)P(B_k)\\] 平均值 均值 \\[\\sum_{x\\in X(\\Omega)}x\\cdot Pr(X=x)\\] 也就是期望值 中位数 满足 \\[Pr(X\\leq x) \\geq \\frac{1}{2}且Pr(X\\geq x) \\geq \\frac{1}{2}\\] 的所有\\(x\\in X(\\Omega)\\)组成的集合 众数 满足 \\[Pr(X = x) \\geq Pr(X=x^{&#39;}), \\forall x^{&#39;}\\in X(\\Omega)\\] 的所有\\(x\\in X(\\Omega)\\)组成的集合 期望 \\[EX=\\sum_{\\omega \\in \\Omega}X(\\omega)Pr(\\omega)\\] 性质 \\[E(X+Y)=\\sum_{\\omega \\in \\Omega}(X(\\omega)+Y(\\omega))Pr(\\omega)=EX+EY\\] \\[E(\\alpha X)=\\alpha EX\\] \\[E(XY)=(EX)(EY),如果X和Y是独立的\\] 方差 \\[VX=E((X-EX)^2)\\] 标准差 \\[\\sigma=\\sqrt{VX}\\] 性质 因为\\((EX)\\)是常数， \\[ \\begin{array}{l} VX\\\\\\\\ =E((X-EX)^2)\\\\\\\\ =E(X^2-2X(EX)+(EX)^2)\\\\\\\\ =E(X^2)-2(EX)(EX)+(EX)^2\\\\\\\\ =E(X^2)-(EX)^2 \\end{array} \\] 当\\(X\\)和\\(Y\\)为独立的随机变量时， \\[ \\begin{array}{l} V(X+Y)\\\\\\\\ =E((X+Y)^2)-(EX+EY)^2\\\\\\\\ =E(X^2)+2(EX)(EY)+E(Y^2)-(EX)^2-2(EX)(EY)-(EY)^2\\\\\\\\ =E(X^2)-(EX)^2+E(Y^2)-(EY)^2\\\\\\\\ =VX+VY \\end{array} \\] 整数概率公式 \\[E(x)=\\sum_{i=1}^{\\infty}P(x\\geq i)\\] 正整数随机变量的期望等于其分别大于等于所有数的概率之和 证明 \\[E(x)=\\sum_{i=1}^{\\infty}iP(x=i)=\\sum_{i=1}^{\\infty}i[P(x\\geq i)-P(x\\geq i+1)]=\\sum_{i=1}^{\\infty}P(x\\geq i)\\]","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"},{"name":"概率","slug":"概率","permalink":"http://x.phoenixgs.cn/tags/概率/"}]},{"title":"线性基","slug":"线性基","date":"2018-10-24T15:12:30.000Z","updated":"2018-11-30T07:59:49.282Z","comments":true,"path":"线性基/","link":"","permalink":"http://x.phoenixgs.cn/线性基/","excerpt":"简介 设数集\\(T\\)，\\(T\\)的线性基为最小的一个集合\\(S\\)，\\(S\\)与\\(T\\)通过异或运算能产生的集合相同，也就是\\(S\\)是\\(T\\)的线性无关极大子集 性质 线性基的异或集合中每个元素的异或方案唯一 线性基二进制最高位互不相同","text":"简介 设数集\\(T\\)，\\(T\\)的线性基为最小的一个集合\\(S\\)，\\(S\\)与\\(T\\)通过异或运算能产生的集合相同，也就是\\(S\\)是\\(T\\)的线性无关极大子集 性质 线性基的异或集合中每个元素的异或方案唯一 线性基二进制最高位互不相同 维护 插入 123456789101112131415161718void insert(long long x)&#123; for (int i = 60; i &gt;= 0; i--) &#123; if ((1ll &lt;&lt; i) &amp; x) &#123; if (v[i]) &#123; x = x ^ v[i]; &#125; else &#123; v[i] = x; return; &#125; &#125; &#125;&#125; 合并 将一个线性基暴力插入到另一个线性基 查询一个数能否被这个线性基表示 123456789101112131415161718bool query(long long x)&#123; for (int i = 60; i &gt;= 0; i--) &#123; if ((1ll &lt;&lt; i) &amp; x) &#123; if (v[i]) &#123; x = x ^ v[i]; &#125; else &#123; return false; &#125; &#125; &#125; return true;&#125; 最大值 12345678ans = 0;for (int i = 51; i &gt;= 0; i--)&#123; if ((ans ^ v[i]) &gt; ans) &#123; ans = ans ^ v[i]; &#125;&#125; 第k小值 123456789101112131415161718192021222324252627282930313233343536373839void build()&#123; for (int i = 0; i &lt;= 60; i++) &#123; for (int j = i - 1; j &gt;= 0; j--) &#123; if ((1ll &lt;&lt; j) &amp; v[i]) &#123; v[i] ^= v[j]; &#125; &#125; &#125; last = 0; for (int i = 0; i &lt;= 60; i++) &#123; if (v[i]) &#123; vv[last] = v[i]; last++; &#125; &#125;&#125;long long query(long long k)&#123; if (k &gt;= (1ll &lt;&lt; last)) &#123; return (long long)-1; &#125; long long ans = 0; for (int i = 0; i &lt; last; i++) &#123; if ((1ll &lt;&lt; i) &amp; k) &#123; ans = ans ^ vv[i]; &#125; &#125; return ans;&#125; 参考 https://blog.csdn.net/qaq__qaq/article/details/53812883","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"},{"name":"线性基","slug":"线性基","permalink":"http://x.phoenixgs.cn/tags/线性基/"}]},{"title":"关于证明","slug":"证明","date":"2018-10-23T15:30:35.000Z","updated":"2018-12-27T08:29:06.472Z","comments":true,"path":"证明/","link":"","permalink":"http://x.phoenixgs.cn/证明/","excerpt":"证明的方法 用来证明形如\\(\\forall x(P(x)\\to Q(x))\\)的定理 直接证明法 也就是条件语句\\(p\\to q\\) 反证法 条件语句\\(p\\to q\\)等价于它的逆否命题\\(\\neg q \\to \\neg p\\)","text":"证明的方法 用来证明形如\\(\\forall x(P(x)\\to Q(x))\\)的定理 直接证明法 也就是条件语句\\(p\\to q\\) 反证法 条件语句\\(p\\to q\\)等价于它的逆否命题\\(\\neg q \\to \\neg p\\) 空证明和平凡证明 空证明 如果知道\\(p\\)为假，那么就能证明条件语句\\(p \\to q\\)为真 平凡证明 如果知道\\(q\\)为真，那么就能证明条件语句\\(p \\to q\\)为真 归谬证明法 假如要证明命题\\(p\\)是真的。假定我们能找到一个矛盾式\\(q\\)使得\\(\\neg p \\to q\\)为真。那么这就意味着\\(p\\)为真 因为\\(r \\land \\neg r\\)一定是一个矛盾式，所以如果我们能够证明对某个命题\\(r\\)，\\(\\neg p \\to (r \\land \\neg r)\\)为真，就能证明\\(p\\)是真的。 举例 证明\\(\\sqrt{2}\\)是无理数 证明 设\\(p\\)是命题“\\(\\sqrt{2}\\)是无理数“。假定\\(\\neg p\\)为真，即“\\(\\sqrt{2}\\)为有理数，则存在整数\\(a\\)和\\(b\\)满足\\(\\sqrt{2}=\\frac{a}{b}\\)其中\\(b \\neq 0\\)并且\\(a\\)和\\(b\\)没有公因子 等式两端取平方，则 \\[2=\\frac{a^2}{b^2}\\] 因此 \\[2b^2=a^2\\] 可得\\(a^2\\)是偶数，通过反证法可得出\\(a\\)也是偶数，那么\\(\\exists c\\)有\\(a=2c\\)。那么 \\[2b^2=4c^2\\] 等式两端除以\\(2\\)得 \\[b^2=2c^2\\] 同理可得\\(b\\)是偶数。 我们证明了假设\\(\\neg p\\)导致等式\\(\\sqrt{2}=\\frac{a}{b}\\)并且\\(a\\)和\\(b\\)没有公因子，又推出\\(a\\)和\\(b\\)有公因子\\(2\\)，推出了矛盾，因此证明了\\(p\\)为真 等价证明法 为了证明一个双条件命题的定理，即形如\\(p \\leftrightarrow q\\)的语句，那么只需证明\\(p \\to q\\)和\\(q \\to p\\)都是真的。 因为 \\[(p \\leftrightarrow q) \\leftrightarrow(p \\to q) \\land (q \\to p)\\] 反例证明法 如果要证明形如\\(\\forall x P(x)\\)的语句为假，只要能找到一个反例\\(x\\)使\\(P(x)\\)为假 穷举证明法和分情形证明法 为了证明如下的条件语句 \\[(p_1 \\lor p_2 \\lor \\cdots \\lor p_n) \\to q\\] 可以用永真式 \\[[(p_1 \\lor p_2 \\lor \\cdots \\lor p_n) \\to q] \\leftrightarrow [(p_1 \\to q) \\land (p_2 \\to q) \\land \\cdots \\land (p_n \\to q)]\\] 这种论证称为分情形证明法 穷举证明法 如果一些证明只需通过检验相对少量的例子来证明，那么这样的证明叫做穷举证明法，一个穷举证明法是分情形证明的特例 分情形证明法 分情形证明一定要覆盖定理中出现的所有可能情况 存在性证明 \\(\\exists xP(x)\\)这类命题的证明称为存在性证明。 有时可以通过找出一个使得\\(P(a)\\)为真的元素\\(a\\)来给出\\(\\exists xP(x)\\)的存在性证明。这样的存在性证明称为是构造性的，也可以给出一种非构造性的存在性证明，即不是找出使\\(P(a)\\)为真的元素\\(a\\)，而是以某种其他方式来证明\\(\\exists xP(x)\\)为真。给出非构造性证明的一种常用方法是使用归谬证明，证明该存在量化式的否定式蕴含一个矛盾。 一个非构造性的存在性证明 证明存在无理数\\(x\\)和\\(y\\)使得\\(x^y\\)是有理数 证明 由之前的例子可得\\(\\sqrt{2}\\)是无理数，考虑数\\(\\sqrt{2}^{\\sqrt{2}}\\)，如果它是有理数，那就存在两个无理数\\(x\\)和\\(y\\)是有理数，即\\(x=\\sqrt{2}, y=\\sqrt{2}\\)，另一方面如果\\(\\sqrt{2}^{\\sqrt{2}}\\)是无理数，那么令\\(x=\\sqrt{2}^{\\sqrt{2}},y=\\sqrt{2}\\)，因此\\(x^y=(\\sqrt{2}^{\\sqrt{2}})^{\\sqrt{2}}=\\sqrt{2}^{(\\sqrt{2}\\cdot \\sqrt{2})}=\\sqrt{2}^{2}=2\\) 唯一性证明 唯一性证明的两个部分如下 存在性：证明存在某个元素\\(x\\)具有期望的性质 唯一性：证明如果\\(y \\neq x\\)，则\\(y\\)不具有期望的性质 我们也可以等价地证明如果\\(x\\)和\\(y\\)都具有期望的性质，则\\(x=y\\)","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"}]},{"title":"反演","slug":"反演","date":"2018-10-16T15:08:32.000Z","updated":"2018-11-30T07:58:50.153Z","comments":true,"path":"反演/","link":"","permalink":"http://x.phoenixgs.cn/反演/","excerpt":"","text":"反演原理 设 \\[ g_n = \\sum_{i = 0} ^ n a_{ni}f_i \\] \\[ \\sum_{i = 0}^n b_{ni}g_i = f_n \\] 因此，反演公式要成立，即 \\[ \\sum_{k = j}^ib_{ik}a_{kj} = [i = j] = \\delta_{ij} \\] \\[ \\sum_{k = j}^ia_{ik}b_{kj} = [i = j] = \\delta_{ij} \\] 二项式反演","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"}]},{"title":"Prufer序","slug":"Prufer","date":"2018-10-16T15:05:16.000Z","updated":"2018-12-27T08:28:28.136Z","comments":true,"path":"Prufer/","link":"","permalink":"http://x.phoenixgs.cn/Prufer/","excerpt":"Prufer序 一个Prufer数列和一个带编号的无根树是一一对应的 树-&gt;Prufer序 每次找这棵树中编号最小的叶子节点，将与这个点相连的点加入Prufer序，去掉这个点以及相连的边。重复这个操作直到剩下两个点。 Prufer序-&gt;树 设点集$ V={1,2,...,n} \\(，每次在\\)V\\(中找出最小的未在Prufer序中出现过的数，然后在\\)V\\(中删除，与Prufer序中的第一个数相连，Prufer序中的第一个数删除。重复这个操作直到\\)|V|=2\\(（Prufer序为空），最后将\\)V$中的两个点相连。","text":"Prufer序 一个Prufer数列和一个带编号的无根树是一一对应的 树-&gt;Prufer序 每次找这棵树中编号最小的叶子节点，将与这个点相连的点加入Prufer序，去掉这个点以及相连的边。重复这个操作直到剩下两个点。 Prufer序-&gt;树 设点集$ V={1,2,...,n} \\(，每次在\\)V\\(中找出最小的未在Prufer序中出现过的数，然后在\\)V\\(中删除，与Prufer序中的第一个数相连，Prufer序中的第一个数删除。重复这个操作直到\\)|V|=2\\(（Prufer序为空），最后将\\)V$中的两个点相连。 证明 这个感性理解一下感觉很有道理的 注意到，如果一个节点A不是叶子节点，那么它至少有两条边；但在上述过程结束后，整个图只剩下一条边，因此节点A的至少一个相邻节点被去掉过，节点A的编号将会在这棵树对应的Prüfer编码中出现。反过来，在Prüfer编码中出现过的数字显然不可能是这棵树（初始时）的叶子。于是我们看到，没有在Prüfer编码中出现过的数字恰好就是这棵树（初始时）的叶子节点。找出没有出现过的数字中最小的那一个（比如④），它就是与Prüfer编码中第一个数所标识的节点（比如③）相邻的叶子。接下来，我们递归地考虑后面n-3位编码（别忘了编码总长是n-2）：找出除④以外不在后n-3位编码中的最小的数（左图的例子中是⑦），将它连接到整个编码的第2个数所对应的节点上（例子中还是③）。再接下来，找出除④和⑦以外后n-4位编码中最小的不被包含的数，做同样的处理……依次把③⑧②⑤⑥与编码中第3、4、5、6、7位所表示的节点相连。最后，我们还有①和⑨没处理过，直接把它们俩连接起来就行了。由于没处理过的节点数总比剩下的编码长度大2，因此我们总能找到一个最小的没在剩余编码中出现的数，算法总能进行下去。这样，任何一个Prüfer编码都唯一地对应了一棵无根树，有多少个n-2位的Prüfer编码就有多少个带标号的无根树。 ——摘自Matrix67 性质 一棵n个节点的无根树唯一地对应了一个长度为n-2的数列，数列中的每个数都在1到n的范围内。 Prufer序列中某个编号出现的次数就等于这个编号的节点在无根树中的度数-1。 设无根树每个点的度数为\\(D_i\\)，则\\(\\sum_{i=1}^n(D_i-1)=n-2\\)（这好像是废话，，，因为\\(\\sum_{i=1}^nD_i=2(n-1)\\)。。。 Cayley公式 Cayley公式 一个完全图\\(K_n\\)有\\(n^{n-2}\\)棵生成树 证明 由Prufer可知，一个Prufer数列和一个带编号的无根树是一一对应的，那么这个公式也很显然了。因为\\(n\\)个节点的无根树的Prufer序长度为\\(n-2\\)，序列中每个值取值为\\({1,2,3,...,n}\\)，因此不同的Prufer序有\\(n^{n-2}\\)个，因此生成树也有这么多个。 推广 n个节点的度依次为\\(D_1,D_2,...,D_n\\)的无根树共有\\(\\frac{(n-2)!}{(D_1-1)!(D_2-1)!\\cdots(D_n-1)!}\\)个。 例题 BZOJ1005 LOJ6395 https://www.cnblogs.com/onioncyc/p/9052946.html 参考资料 http://www.matrix67.com/blog/archives/682 https://www.cnblogs.com/dirge/p/5503289.html","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://x.phoenixgs.cn/tags/算法/"},{"name":"树","slug":"树","permalink":"http://x.phoenixgs.cn/tags/树/"}]},{"title":"容斥原理","slug":"容斥原理","date":"2018-06-11T14:14:15.000Z","updated":"2018-11-30T07:58:59.235Z","comments":true,"path":"容斥原理/","link":"","permalink":"http://x.phoenixgs.cn/容斥原理/","excerpt":"表达式 容斥原理 \\[ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1}|A_i|- \\sum_{1 \\leq i &lt; j \\leq n}|A_i \\cap A_j|+\\\\\\\\ \\sum_{1 \\leq i &lt; j &lt; k \\leq n}|A_i \\cap A_j \\cap A_k| - \\cdots +(-1)^{n-1}|A_1 \\cap A_2 \\cap \\cdots \\cap A_n| \\] \\[ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1} |A_i| - \\sum_{1 \\leq i &lt; j \\leq n} |A_i \\cap A_j|+ \\sum_{1 \\leq i &lt; j &lt; k \\leq n} |A_i \\cap A_j \\cap A_k| - \\cdots + (-1)^{n-1} |A_1 \\cap A_2 \\cap \\cdots \\cap A_n| \\]","text":"表达式 容斥原理 \\[ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1}|A_i|- \\sum_{1 \\leq i &lt; j \\leq n}|A_i \\cap A_j|+\\\\\\\\ \\sum_{1 \\leq i &lt; j &lt; k \\leq n}|A_i \\cap A_j \\cap A_k| - \\cdots +(-1)^{n-1}|A_1 \\cap A_2 \\cap \\cdots \\cap A_n| \\] \\[ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1} |A_i| - \\sum_{1 \\leq i &lt; j \\leq n} |A_i \\cap A_j|+ \\sum_{1 \\leq i &lt; j &lt; k \\leq n} |A_i \\cap A_j \\cap A_k| - \\cdots + (-1)^{n-1} |A_1 \\cap A_2 \\cap \\cdots \\cap A_n| \\] ## 逐步淘汰原理（筛法公式） \\[ | \\complement_S A_1 \\cap \\complement_S A_2 \\cap \\cdots \\cap \\complement_S A_n| = |S|-\\sum^n_{i=1}|A_i|+ \\sum_{1 \\leq i &lt; j \\leq n}|A_i \\cap A_j|-\\\\\\\\ \\sum_{1 \\leq i &lt; j &lt; k \\leq n}|A_i \\cap A_j \\cap A_k| + \\cdots +(-1)^n|A_1 \\cap A_2 \\cap \\cdots \\cap A_n| \\] # 容斥原理与求和及差分 以二维求和为例 \\[ \\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}=\\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[i\\neq n \\lor j\\neq m]+x_{n,m} \\\\\\\\ = \\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[i\\neq n]+\\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[j\\neq m] -\\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[i\\neq n \\land j\\neq m]+x_{i,j} \\]","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"}]},{"title":"dsu on tree","slug":"dsu-on-tree","date":"2018-05-20T11:24:02.000Z","updated":"2018-05-20T11:24:02.452Z","comments":true,"path":"dsu-on-tree/","link":"","permalink":"http://x.phoenixgs.cn/dsu-on-tree/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"Hello-World","date":"2016-05-29T03:07:22.000Z","updated":"2018-12-27T14:51:34.246Z","comments":true,"path":"Hello-World/","link":"","permalink":"http://x.phoenixgs.cn/Hello-World/","excerpt":"","text":"123456789#include &lt;cstdio&gt;int main()&#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", x + y); return 0;&#125;","categories":[],"tags":[]}]}