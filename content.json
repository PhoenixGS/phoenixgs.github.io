{"meta":{"title":"PhoenixGS","subtitle":null,"description":null,"author":"PhoenixGS","url":"http://x.phoenixgs.cn"},"pages":[],"posts":[{"title":"HDU 4333 Revolving Digits","slug":"HDU-4333","date":"2018-04-10T06:02:55.000Z","updated":"2018-04-10T06:08:30.481Z","comments":true,"path":"2018/04/10/HDU-4333/","link":"","permalink":"http://x.phoenixgs.cn/2018/04/10/HDU-4333/","excerpt":"题意求所有与N循环同构的字符串中，转换成字符串后有几个比它小，相等，比它大","text":"题意求所有与N循环同构的字符串中，转换成字符串后有几个比它小，相等，比它大 题解扩展KMP求出extend之后，下一个字符比较一下就可以了，然后输出的是本质不同的字符串的个数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int T, n;char s[200000];int nextx[200000];int ans1, ans2, ans3;int cas;int main()&#123; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%s\", s); n = strlen(s); nextx[0] = n; int pos = -1, last = -1; for (int i = 1; i &lt; n; i++) &#123; int k = (pos == -1 || i &gt; last) ? 0 : std::min(nextx[i - pos], last - i + 1); while (k &lt; n &amp;&amp; s[k] == s[(i + k) % n]) &#123; k++; &#125; nextx[i] = k; if (i + nextx[i] - 1 &gt; last) &#123; pos = i; last = i + nextx[i] - 1; &#125; &#125; ans1 = ans2 = ans3 = 0; for (int i = 0; i &lt; n; i++) &#123; if (nextx[i] == n) &#123; ans2++; &#125; else &#123; if (s[(i + nextx[i]) % n] &gt; s[nextx[i]]) &#123; ans3++; &#125; else &#123; ans1++; &#125; &#125; &#125; cas++; printf(\"Case %d: %d %d %d\\n\", cas, ans1 / ans2, ans2 / ans2, ans3 / ans2); &#125; return 0;&#125;","categories":[],"tags":[{"name":"扩展KMP","slug":"扩展KMP","permalink":"http://x.phoenixgs.cn/tags/扩展KMP/"}]},{"title":"51nod 1286 三段子串","slug":"51nod-1286","date":"2018-04-10T01:14:25.000Z","updated":"2018-04-10T01:21:35.685Z","comments":true,"path":"2018/04/10/51nod-1286/","link":"","permalink":"http://x.phoenixgs.cn/2018/04/10/51nod-1286/","excerpt":"题意 给定一个字符串S，找到另外一个字符串T，T既是S的前缀，也是S的后缀，并且在中间某个地方也出现一次，并且这三次出现不重合。求T最长的长度。","text":"题意 给定一个字符串S，找到另外一个字符串T，T既是S的前缀，也是S的后缀，并且在中间某个地方也出现一次，并且这三次出现不重合。求T最长的长度。 题解跑一遍KMP和扩展KMP，然后从大到小枚举所有的T使T是S的前缀和后缀，然后维护一段区间的extend的最大值，由于T是从大到小枚举的，所以区间是从小到大的。时间复杂度$ O(n) $ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;int n;char s[2000000];int fail[2000000], nextx[2000000];void getfail()&#123; int j = 0; for (int i = 2; i &lt;= n; i++) &#123; while (j &amp;&amp; s[j + 1] != s[i]) &#123; j = fail[j]; &#125; if (s[j + 1] == s[i]) &#123; j++; &#125; fail[i] = j; &#125;&#125;void getnextx()&#123; nextx[1] = n; int pos = -1, last = -1; for (int i = 2; i &lt;= n; i++) &#123; int k = (pos == -1 || i &gt; last) ? 0 : std::min(nextx[i - pos + 1], last - i + 1); while (k &lt; n &amp;&amp; s[k + 1] == s[i + k]) &#123; k++; &#125; nextx[i] = k; if (i + nextx[i] - 1 &gt; last) &#123; pos = i; last = i + nextx[i] - 1; &#125; &#125;&#125;int main()&#123; scanf(\"%s\", s + 1); n = strlen(s + 1); getfail(); getnextx(); int maxx = 0; int k = fail[n]; for (; k * 3 &gt; n; k = fail[k]); int l = k + 1; int r = n - 2 * k + 1; for (int i = l; i &lt;= r; i++) &#123; maxx = std::max(maxx, nextx[i]); &#125; if (maxx &gt;= k) &#123; printf(\"%d\\n\", k); return 0; &#125; for (k = fail[k]; k; k = fail[k]) &#123; int ll = k + 1; int rr = n - 2 * k + 1; for (int i = ll; i &lt; l; i++) &#123; maxx = std::max(maxx, nextx[i]); &#125; for (int i = r + 1; i &lt;= rr; i++) &#123; maxx = std::max(maxx, nextx[i]); &#125; l = ll; r = rr; if (maxx &gt;= k) &#123; printf(\"%d\\n\", k); return 0; &#125; &#125; printf(\"0\\n\"); return 0;&#125;","categories":[],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://x.phoenixgs.cn/tags/KMP/"},{"name":"扩展KMP","slug":"扩展KMP","permalink":"http://x.phoenixgs.cn/tags/扩展KMP/"}]},{"title":"BZOJ 1009 [HNOI2008]GT考试","slug":"BZOJ-1009","date":"2018-04-09T02:30:51.000Z","updated":"2018-04-10T01:21:34.624Z","comments":true,"path":"2018/04/09/BZOJ-1009/","link":"","permalink":"http://x.phoenixgs.cn/2018/04/09/BZOJ-1009/","excerpt":"题意有多少个n位数字，其中没有出现过A","text":"题意有多少个n位数字，其中没有出现过A 题解很simple的一个DP就是f[i][j]表示现在字符串长度为i，匹配到A的KMP的状态为j，然后用矩阵乘法优化一下就好了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;cstring&gt;int n, m, M;char s[1000];int nextx[1000];int mat[22][22], ans[22][22], z[22][22];int anss;void getnextx()&#123; int j = 0; for (int i = 2; i &lt;= m; i++) &#123; while (j &amp;&amp; s[j + 1] != s[i]) &#123; j = nextx[j]; &#125; if (s[j + 1] == s[i]) &#123; j++; &#125; nextx[i] = j; &#125;&#125;void mul(int x[22][22], int y[22][22])&#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; z[i][j] = 0; &#125; &#125; for (int k = 0; k &lt; m; k++) &#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; z[i][j] = (z[i][j] + (long long)x[i][k] * y[k][j] % M) % M; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; x[i][j] = z[i][j]; &#125; &#125;&#125;int main()&#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;M); scanf(\"%s\", s + 1); getnextx(); for (int i = 0; i &lt; m; i++) &#123; for (char j = '0'; j &lt;= '9'; j++) &#123; int tmp = i; while (tmp &amp;&amp; s[tmp + 1] != j) &#123; tmp = nextx[tmp]; &#125; if (s[tmp + 1] == j) &#123; tmp++; &#125; if (tmp != m) &#123; mat[i][tmp]++; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; ans[i][i] = 1; &#125; while (n) &#123; if (n &amp; 1) &#123; mul(ans, mat); &#125; mul(mat, mat); n &gt;&gt;= 1; &#125; anss = 0; for (int i = 0; i &lt; m; i++) &#123; anss = (anss + ans[0][i]) % M; &#125; printf(\"%d\\n\", anss); return 0;&#125;","categories":[],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://x.phoenixgs.cn/tags/KMP/"}]},{"title":"BZOJ 3670 [Noi2014]动物园","slug":"BZOJ-3670","date":"2018-04-09T02:21:11.000Z","updated":"2018-04-10T01:21:38.016Z","comments":true,"path":"2018/04/09/BZOJ-3670/","link":"","permalink":"http://x.phoenixgs.cn/2018/04/09/BZOJ-3670/","excerpt":"题意 我现在希望求出一个更强大num数组一一对于字符串S的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]。 然后输出$ \\Pi _ {i = 1} ^ L (num[i] + 1) $","text":"题意 我现在希望求出一个更强大num数组一一对于字符串S的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]。 然后输出$ \\Pi _ {i = 1} ^ L (num[i] + 1) $ 题解这道题十分显然，求出nextx数组的同时求出自动机状态里的集合大小，然后枚举区间的右端点，满足题意不重叠的条件之后就可以算答案了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int M = 1000000007;int T;int ans;char s[2000000];int n;int nextx[2000000];int k[2000000];int main()&#123; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%s\", s + 1); n = strlen(s + 1); k[0] = 0; k[1] = 1; int j = 0; for (int i = 2; i &lt;= n; i++) &#123; while (j &amp;&amp; s[j + 1] != s[i]) &#123; j = nextx[j]; &#125; if (s[j + 1] == s[i]) &#123; j++; &#125; nextx[i] = j; k[i] = k[j] + 1; &#125; j = 0; ans = 1; for (int i = 1; i &lt;= n; i++) &#123; while (j &amp;&amp; s[j + 1] != s[i]) &#123; j = nextx[j]; &#125; if (s[j + 1] == s[i]) &#123; j++; &#125; while (j &gt; i / 2) &#123; j = nextx[j]; &#125; ans = (long long)ans * (k[j] + 1) % M; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://x.phoenixgs.cn/tags/KMP/"}]},{"title":"HDU 2594 Simpsons’ Hidden Talents","slug":"HDU-2594","date":"2018-04-08T13:00:39.000Z","updated":"2018-04-10T01:21:40.168Z","comments":true,"path":"2018/04/08/HDU-2594/","link":"","permalink":"http://x.phoenixgs.cn/2018/04/08/HDU-2594/","excerpt":"题意求出最大的k使s1长度为k的前缀等于s2长度为k的后缀","text":"题意求出最大的k使s1长度为k的前缀等于s2长度为k的后缀 题解扩展KMP模版题，求出extend之后，从前往后枚举位置i，只要往后extend[i]能到末尾就输出答案 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;char s[100000], t[100000];int n, m;int nextx[100000], extend[100000];int ans;void getnextx()&#123; int pos = -1, last = -1; for (int i = 2; i &lt;= m; i++) &#123; int k = (pos == -1 || i &gt; last) ? 0 : std::min(nextx[i - pos + 1], last - i + 1); while (k + 1 &lt;= n &amp;&amp; t[i + k] == t[k + 1]) &#123; k++; &#125; nextx[i] = k; if (i + nextx[i] - 1 &gt; last) &#123; pos = i; last = i + nextx[i] - 1; &#125; &#125;&#125;int main()&#123; while (scanf(\"%s%s\", s + 1, t + 1) == 2) &#123; n = strlen(s + 1); m = strlen(t + 1); getnextx(); int pos = -1, last = -1; for (int i = 1; i &lt;= m; i++) &#123; int k = (pos == -1 || i &gt; last) ? 0 : std::min(nextx[i - pos + 1], last - i + 1); while (k + 1 &lt;= n &amp;&amp; i + k &lt;= m &amp;&amp; t[i + k] == s[k + 1]) &#123; k++; &#125; extend[i] = k; if (i + extend[i] - 1 &gt; last) &#123; pos = i; last = i + extend[i] - 1; &#125; &#125; ans = 0; for (int i = 1; i &lt;= m; i++) &#123; if (i + extend[i] - 1 == m) &#123; ans = extend[i]; break; &#125; &#125; if (ans) &#123; for (int i = 1; i &lt;= ans; i++) &#123; printf(\"%c\", s[i]); &#125; printf(\" \"); &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"扩展KMP","slug":"扩展KMP","permalink":"http://x.phoenixgs.cn/tags/扩展KMP/"}]},{"title":"Hello World","slug":"Hello-World","date":"2016-05-29T03:07:22.000Z","updated":"2018-04-09T16:28:03.783Z","comments":true,"path":"2016/05/29/Hello-World/","link":"","permalink":"http://x.phoenixgs.cn/2016/05/29/Hello-World/","excerpt":"","text":"123456789#include &lt;cstdio&gt;int main()&#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", x + y); return 0;&#125;","categories":[],"tags":[]}]}