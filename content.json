{"meta":{"title":"PhoenixGS","subtitle":null,"description":null,"author":"PhoenixGS","url":"http://x.phoenixgs.cn"},"pages":[{"title":"About","date":"2018-04-10T07:35:55.597Z","updated":"2018-04-10T07:35:55.561Z","comments":true,"path":"about/index.html","permalink":"http://x.phoenixgs.cn/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-04-10T07:36:06.983Z","updated":"2018-04-10T07:36:06.949Z","comments":true,"path":"categories/index.html","permalink":"http://x.phoenixgs.cn/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-04-10T07:36:14.332Z","updated":"2018-04-10T07:36:14.299Z","comments":true,"path":"tags/index.html","permalink":"http://x.phoenixgs.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"反演","slug":"反演","date":"2018-10-16T15:08:32.000Z","updated":"2018-10-16T15:08:46.252Z","comments":true,"path":"2018/10/16/反演/","link":"","permalink":"http://x.phoenixgs.cn/2018/10/16/反演/","excerpt":"","text":"反演反演原理设 $$ g_n = \\sum_{i = 0} ^ n a_{ni}f_i $$ $$ \\sum_{i = 0}^n b_{ni}g_i = f_n $$ 因此，反演公式要成立，即 $$ \\sum_{k = j}^ib_{ik}a_{kj} = [i = j] = \\delta_{ij} $$ $$ \\sum_{k = j}^ia_{ik}b_{kj} = [i = j] = \\delta_{ij} $$ 二项式反演","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"}]},{"title":"Prufer","slug":"Prufer","date":"2018-10-16T15:05:16.000Z","updated":"2018-10-16T15:09:56.410Z","comments":true,"path":"2018/10/16/Prufer/","link":"","permalink":"http://x.phoenixgs.cn/2018/10/16/Prufer/","excerpt":"Prufer序Prufer序一个Prufer数列和一个带编号的无根树是一一对应的 树-&gt;Prufer序每次找这棵树中编号最小的叶子节点，将与这个点相连的点加入Prufer序，去掉这个点以及相连的边。重复这个操作直到剩下两个点。 Prufer序-&gt;树设点集$ V={1,2,…,n} $，每次在$V$中找出最小的未在Prufer序中出现过的数，然后在$V$中删除，与Prufer序中的第一个数相连，Prufer序中的第一个数删除。重复这个操作直到$|V|=2$（Prufer序为空），最后将$V$中的两个点相连。","text":"Prufer序Prufer序一个Prufer数列和一个带编号的无根树是一一对应的 树-&gt;Prufer序每次找这棵树中编号最小的叶子节点，将与这个点相连的点加入Prufer序，去掉这个点以及相连的边。重复这个操作直到剩下两个点。 Prufer序-&gt;树设点集$ V={1,2,…,n} $，每次在$V$中找出最小的未在Prufer序中出现过的数，然后在$V$中删除，与Prufer序中的第一个数相连，Prufer序中的第一个数删除。重复这个操作直到$|V|=2$（Prufer序为空），最后将$V$中的两个点相连。 证明这个感性理解一下感觉很有道理的 ​ 注意到，如果一个节点A不是叶子节点，那么它至少有两条边；但在上述过程结束后，整个图只剩下一条边，因此节点A的至少一个相邻节点被去掉过，节点A的编号将会在这棵树对应的Prüfer编码中出现。反过来，在Prüfer编码中出现过的数字显然不可能是这棵树（初始时）的叶子。于是我们看到，没有在Prüfer编码中出现过的数字恰好就是这棵树（初始时）的叶子节点。找出没有出现过的数字中最小的那一个（比如④），它就是与Prüfer编码中第一个数所标识的节点（比如③）相邻的叶子。接下来，我们递归地考虑后面n-3位编码（别忘了编码总长是n-2）：找出除④以外不在后n-3位编码中的最小的数（左图的例子中是⑦），将它连接到整个编码的第2个数所对应的节点上（例子中还是③）。再接下来，找出除④和⑦以外后n-4位编码中最小的不被包含的数，做同样的处理……依次把③⑧②⑤⑥与编码中第3、4、5、6、7位所表示的节点相连。最后，我们还有①和⑨没处理过，直接把它们俩连接起来就行了。由于没处理过的节点数总比剩下的编码长度大2，因此我们总能找到一个最小的没在剩余编码中出现的数，算法总能进行下去。这样，任何一个Prüfer编码都唯一地对应了一棵无根树，有多少个n-2位的Prüfer编码就有多少个带标号的无根树。 ——摘自Matrix67 性质 一棵n个节点的无根树唯一地对应了一个长度为n-2的数列，数列中的每个数都在1到n的范围内。 Prufer序列中某个编号出现的次数就等于这个编号的节点在无根树中的度数-1。 设无根树每个点的度数为$D_i$，则$\\sum_{i=1}^n(D_i-1)=n-2$（这好像是废话，，，因为$\\sum_{i=1}^nD_i=2(n-1)$。。。 Cayley公式Cayley公式一个完全图$K_n$有$n^{n-2}$棵生成树 证明由Prufer可知，一个Prufer数列和一个带编号的无根树是一一对应的，那么这个公式也很显然了。因为$n$个节点的无根树的Prufer序长度为$n-2$，序列中每个值取值为${1,2,3,…,n}$，因此不同的Prufer序有$n^{n-2}$个，因此生成树也有这么多个。 推广n个节点的度依次为$D_1,D_2,…,D_n$的无根树共有$\\frac{(n-2)!}{(D_1-1)!(D_2-1)!\\cdots(D_n-1)!}$个。 例题BZOJ1005 LOJ6395 https://www.cnblogs.com/onioncyc/p/9052946.html 参考资料http://www.matrix67.com/blog/archives/682 https://www.cnblogs.com/dirge/p/5503289.html","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://x.phoenixgs.cn/tags/算法/"},{"name":"树","slug":"树","permalink":"http://x.phoenixgs.cn/tags/树/"}]},{"title":"容斥原理","slug":"容斥原理","date":"2018-06-11T14:14:15.000Z","updated":"2018-10-16T15:11:17.342Z","comments":true,"path":"2018/06/11/容斥原理/","link":"","permalink":"http://x.phoenixgs.cn/2018/06/11/容斥原理/","excerpt":"容斥原理表达式容斥原理$$ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1}|A_i|- \\sum_{1 \\leq i &lt; j \\leq n}|A_i \\cap A_j|+\\\\ \\sum_{1 \\leq i &lt; j &lt; k \\leq n}|A_i \\cap A_j \\cap A_k| - \\cdots +(-1)^{n-1}|A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$$$ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1} |A_i| - \\sum_{1 \\leq i &lt; j \\leq n} |A_i \\cap A_j|+ \\sum_{1 \\leq i &lt; j &lt; k \\leq n} |A_i \\cap A_j \\cap A_k| - \\cdots + (-1)^{n-1} |A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$","text":"容斥原理表达式容斥原理$$ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1}|A_i|- \\sum_{1 \\leq i &lt; j \\leq n}|A_i \\cap A_j|+\\\\ \\sum_{1 \\leq i &lt; j &lt; k \\leq n}|A_i \\cap A_j \\cap A_k| - \\cdots +(-1)^{n-1}|A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$$$ | A_1 \\cup A_2 \\cup \\cdots \\cup A_n | = \\sum^n_{i=1} |A_i| - \\sum_{1 \\leq i &lt; j \\leq n} |A_i \\cap A_j|+ \\sum_{1 \\leq i &lt; j &lt; k \\leq n} |A_i \\cap A_j \\cap A_k| - \\cdots + (-1)^{n-1} |A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$ 逐步淘汰原理（筛法公式）$$ | \\complement_S A_1 \\cap \\complement_S A_2 \\cap \\cdots \\cap \\complement_S A_n| = |S|-\\sum^n_{i=1}|A_i|+ \\sum_{1 \\leq i &lt; j \\leq n}|A_i \\cap A_j|-\\\\ \\sum_{1 \\leq i &lt; j &lt; k \\leq n}|A_i \\cap A_j \\cap A_k| + \\cdots +(-1)^n|A_1 \\cap A_2 \\cap \\cdots \\cap A_n| $$ 容斥原理与求和及差分以二维求和为例$$ \\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}=\\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[i\\neq n \\lor j\\neq m]+x_{n,m} \\\\ = \\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[i\\neq n]+\\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[j\\neq m] \\\\ -\\sum^n_{i=1}\\sum^m_{j=1}x_{i,j}[i\\neq n \\land j\\neq m]+x_{i,j} $$","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://x.phoenixgs.cn/tags/数学/"}]},{"title":"dsu on tree","slug":"dsu-on-tree","date":"2018-05-20T11:24:02.000Z","updated":"2018-05-20T11:24:02.452Z","comments":true,"path":"2018/05/20/dsu-on-tree/","link":"","permalink":"http://x.phoenixgs.cn/2018/05/20/dsu-on-tree/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"Hello-World","date":"2016-05-29T03:07:22.000Z","updated":"2018-04-09T16:28:03.783Z","comments":true,"path":"2016/05/29/Hello-World/","link":"","permalink":"http://x.phoenixgs.cn/2016/05/29/Hello-World/","excerpt":"","text":"123456789#include &lt;cstdio&gt;int main()&#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); printf(\"%d\\n\", x + y); return 0;&#125;","categories":[],"tags":[]}]}